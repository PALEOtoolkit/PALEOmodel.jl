<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PALEOmodel · PALEOmodel Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PALEOmodel Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PALEOmodel.jl</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../MathematicalFormulation/">Mathematical formulation of the reaction-transport problem</a></li></ul></li><li><span class="tocitem">HOWTOs</span><ul><li><a class="tocitem" href="../HOWTOshowmodelandoutput/">Displaying model configuration and output from the Julia REPL</a></li><li><a class="tocitem" href="../HOWTOsmallnegativevalues/">Managing small and negative values</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>PALEOmodel</a><ul class="internal"><li><a class="tocitem" href="#Create-and-initialize"><span>Create and initialize</span></a></li><li><a class="tocitem" href="#Integrate"><span>Integrate</span></a></li><li><a class="tocitem" href="#Field-Array"><span>Field Array</span></a></li><li><a class="tocitem" href="#Output"><span>Output</span></a></li><li><a class="tocitem" href="#Plot-output"><span>Plot output</span></a></li><li><a class="tocitem" href="#Analyze-reaction-network"><span>Analyze reaction network</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../References/">References</a></li><li><a class="tocitem" href="../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>PALEOmodel</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PALEOmodel</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/master/docs/src/PALEOmodel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PALEOmodel"><a class="docs-heading-anchor" href="#PALEOmodel">PALEOmodel</a><a id="PALEOmodel-1"></a><a class="docs-heading-anchor-permalink" href="#PALEOmodel" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Run" href="#PALEOmodel.Run"><code>PALEOmodel.Run</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Run</code></pre><p>Container for model and output.</p><p><strong>Fields</strong></p><ul><li><code>model::Union{Nothing, PB.Model}</code>: The model instance.</li><li><code>output::Union{Nothing, AbstractOutputWriter}</code>: model output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/Run.jl#L2-L10">source</a></section></article><h2 id="Create-and-initialize"><a class="docs-heading-anchor" href="#Create-and-initialize">Create and initialize</a><a id="Create-and-initialize-1"></a><a class="docs-heading-anchor-permalink" href="#Create-and-initialize" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.initialize!" href="#PALEOmodel.initialize!"><code>PALEOmodel.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize!(model::PB.Model; kwargs...) -&gt; (initial_state, modeldata)</code></pre><p>Initialize <code>model</code> and return <code>initial_state</code> Vector and <code>modeldata</code> struct</p><p><strong>Keywords:</strong></p><ul><li><code>eltype::Type=Float64</code>: default data type to use for model arrays</li><li><code>eltypemap=Dict{String, DataType}</code>: Dict of data types to look up Variable :datatype attribute</li><li><code>pickup_output=nothing</code>: OutputWriter with pickup data to initialise from</li><li><code>threadsafe=false</code>: true to create thread safe Atomic Variables where :atomic attribute = true</li><li><code>method_barrier=nothing</code>: thread barrier to add to dispatch lists if <code>threadsafe==true</code></li><li><code>expect_hostdep_varnames=[&quot;global.tforce&quot;]</code>: non-state-Variable host-dependent Variable names expected</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/Run.jl#L32-L44">source</a></section></article><h2 id="Integrate"><a class="docs-heading-anchor" href="#Integrate">Integrate</a><a id="Integrate-1"></a><a class="docs-heading-anchor-permalink" href="#Integrate" title="Permalink"></a></h2><h3 id="DifferentialEquations-solvers"><a class="docs-heading-anchor" href="#DifferentialEquations-solvers">DifferentialEquations solvers</a><a id="DifferentialEquations-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations-solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrate" href="#PALEOmodel.ODE.integrate"><code>PALEOmodel.ODE.integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate(run, initial_state, modeldata, tspan [; kwargs...] )</code></pre><p>Integrate run.model as an ODE or as a DAE with constant mass matrix, and write to <code>outputwriter</code></p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, tstop) integration start and stop times</li></ul><p><strong>Keywords</strong></p><ul><li><code>alg=Sundials.CVODE_BDF()</code>:  ODE algorithm to use</li><li><code>outputwriter=run.output</code>: PALEOmodel.AbstractOutputWriter instance to hold output</li><li><code>solvekwargs=NamedTuple()</code>: NamedTuple of keyword arguments passed through to DifferentialEquations.jl <code>solve</code>  (eg to set <code>abstol</code>, <code>reltol</code>, <code>saveat</code>,  see <a href="https://diffeq.sciml.ai/dev/basics/common_solver_opts/">https://diffeq.sciml.ai/dev/basics/common_solver_opts/</a>)</li><li><code>jac_ad=:NoJacobian</code>: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)</li><li><code>jac_ad_t_sparsity=tspan[1]</code>: model time at which to calculate Jacobian sparsity pattern</li><li><code>steadystate=false</code>: true to use <code>DifferentialEquations.jl</code> <code>SteadyStateProblem</code> (not recommended, see <a href="#PALEOmodel.SteadyState.steadystate"><code>PALEOmodel.SteadyState.steadystate</code></a>).</li><li><code>BLAS_num_threads=1</code>: number of LinearAlgebra.BLAS threads to use</li><li><code>init_logger=Logging.NullLogger()</code>: default value omits logging from (re)initialization to generate Jacobian modeldata, Logging.CurrentLogger() to include</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODE.jl#L147-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrateDAE" href="#PALEOmodel.ODE.integrateDAE"><code>PALEOmodel.ODE.integrateDAE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateDAE(run, initial_state, modeldata, tspan;alg=IDA())</code></pre><p>Integrate run.model as a DAE and copy output to <code>outputwriter</code>.  Arguments as <a href="#PALEOmodel.ODE.integrate"><code>integrate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODE.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrateForwardDiff" href="#PALEOmodel.ODE.integrateForwardDiff"><code>PALEOmodel.ODE.integrateForwardDiff</code></a> — <span class="docstring-category">Function</span></header><section><div><p><a href="#PALEOmodel.ODE.integrate"><code>integrate</code></a> with argument defaults to  use ForwardDiff AD Jacobian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODE.jl#L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrateDAEForwardDiff" href="#PALEOmodel.ODE.integrateDAEForwardDiff"><code>PALEOmodel.ODE.integrateDAEForwardDiff</code></a> — <span class="docstring-category">Function</span></header><section><div><p><a href="#PALEOmodel.ODE.integrateDAE"><code>integrateDAE</code></a> with argument defaults to use ForwardDiff AD Jacobian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODE.jl#L277">source</a></section></article><h3 id="Fixed-timestep-solvers"><a class="docs-heading-anchor" href="#Fixed-timestep-solvers">Fixed timestep solvers</a><a id="Fixed-timestep-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-timestep-solvers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateEuler" href="#PALEOmodel.ODEfixed.integrateEuler"><code>PALEOmodel.ODEfixed.integrateEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateEuler(run, initial_state, modeldata, tspan, Δt; [,outputwriter])</code></pre><p>Integrate run.model using first-order Euler with fixed timestep.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt</code>: (yr) fixed timestep </li><li>[<code>outputwriter</code>: <code>PALEOmodel.AbstractOutputWriter</code> instance to write model output to]</li><li>[<code>report_interval</code>: number of timesteps between progress update to console]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateSplitEuler" href="#PALEOmodel.ODEfixed.integrateSplitEuler"><code>PALEOmodel.ODEfixed.integrateSplitEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateSplitEuler(run, initial_state, modeldata, tspan, Δt_outer, n_inner;
                        cellranges_outer, cellranges_inner,
                        [,outputwriter])</code></pre><p>Integrate run.model representing:</p><p class="math-container">\[\frac{dS}{dt} =  f_{outer}(t, S) + f_{inner}(t, S)\]</p><p>using split first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and a shorter timestep <code>Δt_outer/n_inner</code> for <code>f_inner</code>.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_outer</code>. <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_inner</code>.</p><p>NB: the combined time derivative is written to <code>outputwriter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed outer timestep </li><li><code>n_inner</code>: number of inner timesteps per outer timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>cellranges_outer</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellranges_inner</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_inner</code>.</li><li>[<code>outputwriter</code>: <code>PALEOmodel.AbstractOutputWriter</code> instance to write model output to]</li><li>[<code>report_interval</code>: number of outer timesteps between progress update to console]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L53-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateEulerthreads" href="#PALEOmodel.ODEfixed.integrateEulerthreads"><code>PALEOmodel.ODEfixed.integrateEulerthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateEulerthreads(run, initial_state, modeldata, cellranges, tspan, Δt;
    outputwriter=run.output, report_interval=1000)</code></pre><p>Integrate run.model using first-order Euler with fixed timestep <code>Δt</code>, with tiling over multiple threads.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>cellranges::Vector{Vector{AbstractCellRange}}</code>: Vector of Vector-of-cellranges, one per thread (so length(cellranges) == Threads.nthreads).</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt</code>: (yr) fixed outer timestep </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L135-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateSplitEulerthreads" href="#PALEOmodel.ODEfixed.integrateSplitEulerthreads"><code>PALEOmodel.ODEfixed.integrateSplitEulerthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateSplitEulerthreads(run, initial_state, modeldata, tspan, Δt_outer, n_inner::Int; 
                            cellranges_outer, cellranges_inner, [,outputwriter] [, report_interval])</code></pre><p>Integrate run.model using split first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and a shorter timestep <code>Δt_outer/n_inner</code> for <code>f_inner</code>.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_outer</code>.  <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_inner</code>.</p><p>Uses <code>Threads.nthreads</code> threads and tiling described by <code>cellranges_inner</code> and <code>cellranges_outer</code> (each a <code>Vector</code> of <code>Vector{AbstractCellRange}</code>, one per thread).</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed outer timestep </li><li><code>n_inner</code>: number of inner timesteps per outer timestep (0 for non-split solver)</li><li><code>cellranges_outer::Vector{Vector{AbstractCellRange}}</code>: Vector of list-of-cellranges, one list per thread (so length(cellranges) == Threads.nthreads), with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellranges_inner::Vector{Vector{AbstractCellRange}}</code>: As <code>cellranges_outer</code>, with <code>operatorID</code> defining <code>f_inner</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L196-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler" href="#PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler"><code>PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateLocalIMEXEuler(run, initial_state, modeldata, tspan, Δt_outer [; kwargs...])</code></pre><p>Integrate run.model representing:</p><p class="math-container">\[\frac{dS}{dt} =  f_{outer}(t, S) + f_{inner}(t, S)\]</p><p>using first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and implicit first-order Euler for <code>f_inner</code>, where <code>f_inner</code> is local (within-cell, ie no transport), for a single Domain, and uses only <code>StateExplicit</code> and <code>Deriv</code> variables.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_outer</code>.  <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_inner</code>.</p><p>NB: the combined time derivative is written to <code>outputwriter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>cellranges_outer</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellrange_inner</code>: A single <code>CellRange</code> with <code>operatorID</code> defining <code>f_inner</code>.</li><li><code>exclude_var_nameroots</code>: State variables that are modified by Reactions in <code>cellrange_inner</code>, but not needed to find implicit solution (ie reaction rates etc don&#39;t depend on them).</li><li>[<code>outputwriter=run.output</code>: <code>PALEOmodel.AbstractOutputWriter</code> instance to write model output to]</li><li>[<code>report_interval=1000</code>: number of outer timesteps between progress update to console]</li><li>[<code>Lnorm_inf_max=1e-3</code>:  normalized error tolerance for implicit solution]</li><li>[<code>niter_max=10</code>]: maximum number of Newton iterations</li><li>[<code>request_adchunksize=4</code>]: request ForwardDiff AD chunk size (will be restricted to an upper limit)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODELocalIMEX.jl#L14-L47">source</a></section></article><h4 id="Fixed-timestep-wrappers"><a class="docs-heading-anchor" href="#Fixed-timestep-wrappers">Fixed timestep wrappers</a><a id="Fixed-timestep-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-timestep-wrappers" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateFixed" href="#PALEOmodel.ODEfixed.integrateFixed"><code>PALEOmodel.ODEfixed.integrateFixed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateFixed(run, initial_state, modeldata, tspan, Δt_outer;
            timesteppers, outputwriter=run.output, report_interval=1000)</code></pre><p>Fixed timestep integration, with time step implemented by <code>timesteppers</code>,</p><pre><code class="nohighlight hljs">`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ...], ...]`</code></pre><p>Where <code>timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L343-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateFixedthreads" href="#PALEOmodel.ODEfixed.integrateFixedthreads"><code>PALEOmodel.ODEfixed.integrateFixedthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateFixedthreads(run, initial_state, modeldata, tspan, Δt_outer;
            timesteppers, outputwriter=run.output, report_interval=1000)</code></pre><p>Fixed timestep integration using <code>Threads.nthreads()</code> threads, with time step implemented by <code>timesteppers</code>,</p><pre><code class="nohighlight hljs">`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ... (1 per thread)], ...]`</code></pre><p>Where <code>timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ODEfixed.jl#L420-L429">source</a></section></article><h3 id="Steady-state-solvers-(Julia-NLsolve-based)"><a class="docs-heading-anchor" href="#Steady-state-solvers-(Julia-NLsolve-based)">Steady-state solvers (Julia NLsolve based)</a><a id="Steady-state-solvers-(Julia-NLsolve-based)-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solvers-(Julia-NLsolve-based)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate" href="#PALEOmodel.SteadyState.steadystate"><code>PALEOmodel.SteadyState.steadystate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate(run, initial_state, modeldata, tss [; kwargs...] )</code></pre><p>Find steady-state solution (using <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> package)  and write to <code>outputwriter</code> (two records are written, for <code>initial_state</code> and the steady-state solution).</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tss</code>:  (yr) model tforce time for steady state solution</li></ul><p><strong>Optional Keywords</strong></p><ul><li><code>outputwriter=run.output</code>: PALEOmodel.AbstractOutputWriter instance to hold output</li><li><code>initial_time=-1.0</code>:  tmodel to write for first output record</li><li><code>solvekwargs=NamedTuple()</code>: NamedTuple of keyword arguments passed through to <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a>  (eg to set <code>method</code>, <code>ftol</code>, <code>iteration</code>, <code>show_trace</code>, <code>store_trace</code>).</li><li><code>jac_ad</code>: :NoJacobian, :ForwardDiffSparse, :ForwardDiff</li><li><code>use_norm=false</code>: true to normalize state variables using PALEO norm_value</li><li><code>BLAS_num_threads=1</code>: number of LinearAlgebra.BLAS threads to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/SteadyState.jl#L21-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystateForwardDiff" href="#PALEOmodel.SteadyState.steadystateForwardDiff"><code>PALEOmodel.SteadyState.steadystateForwardDiff</code></a> — <span class="docstring-category">Function</span></header><section><div><p><a href="#PALEOmodel.SteadyState.steadystate"><code>steadystate</code></a> with argument defaults to  use ForwardDiff AD Jacobian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/SteadyState.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate_ptc" href="#PALEOmodel.SteadyState.steadystate_ptc"><code>PALEOmodel.SteadyState.steadystate_ptc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate_ptc(run, initial_state, modeldata, tss, deltat_initial, tss_max [; kwargs...])</code></pre><p>Find steady-state solution and write to <code>outputwriter</code>, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps from <code>tss</code> to <code>tss_max</code> and <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> as the non-linear solver.</p><p>Each pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton&#39;s method.</p><p>Initial pseudo-timestep Δt is <code>deltat_initial</code>, this is multiplied by <code>deltat_fac</code> for the next iteration until pseudo-time <code>tss_max</code> is reached. If an iteration fails, Δt is divided by <code>deltat_fac</code> and the iteration retried.</p><p>NB: this is a <em>very</em> naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate <code>deltat_fac</code> for each problem.</p><p><strong>Keywords</strong></p><ul><li><code>deltat_fac=2.0</code>: factor to increase pseudo-timestep on success</li><li><code>outputwriter=run.output</code>: output destination</li><li><code>solvekwargs=NamedTuple()</code>: arguments to pass through to NLsolve</li><li><code>jac_ad=:NoJacobian</code>: AD Jacobian to use</li><li><code>request_adchunksize=10</code>: ForwardDiff chunk size to request.</li><li><code>jac_cellranges=modeldata.cellranges_all</code>: CellRanges to use for Jacobian calculation (eg to restrict to an approximate Jacobian)</li><li><code>enforce_noneg=false</code>: fail pseudo-timesteps that generate negative values for state variables.</li><li><code>use_norm=false</code>: true to apply PALEO norm_value to state variables</li><li><code>verbose=false</code>: true to detailed output</li><li><code>BLAS_num_threads=1</code>: restrict threads used by Julia BLAS (likely irrelevant if using sparse Jacobian?)</li></ul><p>See <a href="#PALEOmodel.SteadyState.steadystate"><code>steadystate</code></a> for more details of arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/SteadyState.jl#L184-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate_ptcForwardDiff" href="#PALEOmodel.SteadyState.steadystate_ptcForwardDiff"><code>PALEOmodel.SteadyState.steadystate_ptcForwardDiff</code></a> — <span class="docstring-category">Function</span></header><section><div><p><a href="#PALEOmodel.SteadyState.steadystate_ptc"><code>steadystate_ptc</code></a> with argument defaults to  use ForwardDiff AD Jacobian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/SteadyState.jl#L528">source</a></section></article><h3 id="Steady-state-solvers-(Sundials-Kinsol-based):"><a class="docs-heading-anchor" href="#Steady-state-solvers-(Sundials-Kinsol-based):">Steady-state solvers (Sundials Kinsol based):</a><a id="Steady-state-solvers-(Sundials-Kinsol-based):-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solvers-(Sundials-Kinsol-based):" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyStateKinsol.steadystate_ptc" href="#PALEOmodel.SteadyStateKinsol.steadystate_ptc"><code>PALEOmodel.SteadyStateKinsol.steadystate_ptc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate_ptc(run, initial_state, modeldata, tss, deltat_initial, tss_max; 
    [,deltat_fac=2.0] [,tss_output] [,outputwriter] [,createkwargs] [,solvekwargs]
    [,jac_cellranges] [, use_directional_ad] [, directional_ad_eltypestomap] [,verbose] [,  BLAS_num_threads] )</code></pre><p>Find steady-state solution and write to <code>outputwriter</code>, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps and <a href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> as the non-linear solver.</p><p>Each pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton&#39;s method (preconditioned Newton-Krylov, with the Jacobian as preconditioner)</p><p>Initial pseudo-timestep Δt is <code>deltat_initial</code>, this is multiplied by <code>deltat_fac</code> for the next iteration until pseudo-time <code>tss_max</code> is reached. If an iteration fails, Δt is divided by <code>deltat_fac</code> and the iteration retried.</p><p>NB: this is a <em>very</em> naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate <code>deltat_fac</code> for each problem.</p><p>Solver <a href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> options are set by arguments <code>createkwargs</code> (passed through to <a href="#PALEOmodel.Kinsol.kin_create"><code>PALEOmodel.Kinsol.kin_create</code></a>) and <code>solvekwargs</code> (passed through to <a href="#PALEOmodel.Kinsol.kin_solve"><code>PALEOmodel.Kinsol.kin_solve</code></a>).</p><p>Preconditioner (Jacobian) calculation can be modified by <code>jac_cellranges</code>, to specify a operatorIDs  so use only a subset of Reactions in order to  calculate an approximate Jacobian to use as the preconditioner.</p><p>If <code>use_directional_ad</code> is <code>true</code>, the Jacobian-vector product will be calculated using automatic differentiation (instead of  the default finite difference approximation).  <code>directional_ad_eltypestomap</code> can be used to specify Variable :datatype tags (strings) that should be mapped to the AD directional derivative datatype hence included in the AD directional derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/SteadyStateKinsol.jl#L16-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol" href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Kinsol</code></pre><p>Minimal Julia wrapper for the Sundials kinsol nonlinear system solver <a href="https://computing.llnl.gov/projects/sundials/kinsol">https://computing.llnl.gov/projects/sundials/kinsol</a></p><p>This closely follows the native C interface, as documented in the Kinsol manual, with conversion to-from native Julia types.</p><p>The main user-facing functions are <a href="#PALEOmodel.Kinsol.kin_create"><code>Kinsol.kin_create</code></a> and <a href="#PALEOmodel.Kinsol.kin_solve"><code>Kinsol.kin_solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/Kinsol.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol.kin_create" href="#PALEOmodel.Kinsol.kin_create"><code>PALEOmodel.Kinsol.kin_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kin_create(f, y0 [; kwargs...]) -&gt; kin</code></pre><p>Create and return a kinsol solver context <code>kin</code>, which can then be passed to <a href="#PALEOmodel.Kinsol.kin_solve"><code>kin_solve</code></a></p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function of form f(fy::Vector{Float64}, y::Vector{Float64}, userdata)</li><li><code>y0::Vector</code> template Vector of initial values (used only to define problem dimension)</li></ul><p><strong>Keywords</strong></p><ul><li><code>userdata</code>: optional user data, passed through to <code>f</code> etc.</li><li><code>linear_solver</code>: linear solver to use (only partially implemented, supports :Dense, :Band, :FGMRES)</li><li><code>psolvefun</code>: optional preconditioner solver function (for :FGMRES)</li><li><code>psetupfun</code>: optional preconditioner setup function</li><li><code>jvfun</code>: optional Jacobian*vector  function (for :FGMRES)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/Kinsol.jl#L102-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol.kin_solve" href="#PALEOmodel.Kinsol.kin_solve"><code>PALEOmodel.Kinsol.kin_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kin_solve(
    kin, y0::Vector;
    [strategy] [, fnormtol] [, mxiter] [, print_level] [,y_scale] [, f_scale] [, noInitSetup]
) -&gt; (y, kin_stats)</code></pre><p>Solve nonlinear system using kinsol solver context <code>kin</code> (created by <a href="#PALEOmodel.Kinsol.kin_create"><code>kin_create</code></a>) and initial conditions <code>y0</code>. Returns solution <code>y</code> and solver statistics <code>kinstats</code>. <code>kinstats.returnflag</code> indicates success/failure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/Kinsol.jl#L190-L198">source</a></section></article><h2 id="Field-Array"><a class="docs-heading-anchor" href="#Field-Array">Field Array</a><a id="Field-Array-1"></a><a class="docs-heading-anchor-permalink" href="#Field-Array" title="Permalink"></a></h2><p><a href="#PALEOmodel.FieldArray"><code>FieldArray</code></a> provides a generic array type with named dimensions <code>PALEOboxes.NamedDimension</code> and optional coordinates <code>PALEOboxes.FixedCoord</code> for processing of model output.</p><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.FieldArray" href="#PALEOmodel.FieldArray"><code>PALEOmodel.FieldArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldArray</code></pre><p>A generic <a href="https://xarray.pydata.org/en/stable/index.html">xarray</a>-like or  <a href="https://scitools-iris.readthedocs.io/en/latest/">IRIS</a>-like  Array with named dimensions and optional coordinates.</p><p>NB: this aims to be simple and generic, not efficient !!! Intended for representing model output, not for numerically-intensive calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/FieldArray.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.get_array" href="#PALEOmodel.get_array"><code>PALEOmodel.get_array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_array(obj, ...) -&gt; FieldArray</code></pre><p>Get FieldArray from PALEO object <code>obj</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/FieldArray.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.FieldRecord" href="#PALEOmodel.FieldRecord"><code>PALEOmodel.FieldRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FieldRecord{D &lt;: AbstractData, S &lt;: AbstractSpace, ...}</code></pre><p>A series of records each containing a <code>PALEOboxes.Field</code>.</p><p><strong>Implementation</strong></p><p>Fields with array values are stored in <code>records</code> as a Vector of arrays. Fields with single values (field<em>single</em>element true) are stored as a Vector of eltype(Field.values). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/FieldRecord.jl#L1-L9">source</a></section></article><h2 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters" href="#PALEOmodel.OutputWriters"><code>PALEOmodel.OutputWriters</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">OutputWriters</code></pre><p>Data structures and methods to hold and manage model output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.OutputMemory" href="#PALEOmodel.OutputWriters.OutputMemory"><code>PALEOmodel.OutputWriters.OutputMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutputMemory</code></pre><p>In-memory model output, organized by model Domains.</p><p>Field <code>domains::Dict{String, OutputMemoryDomain}</code> contains per-Domain model output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L371-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.OutputMemoryDomain" href="#PALEOmodel.OutputWriters.OutputMemoryDomain"><code>PALEOmodel.OutputWriters.OutputMemoryDomain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutputMemoryDomain</code></pre><p>In-memory model output, for one model Domain.</p><p>Includes an additional <code>coords_record</code> (usually <code>:tmodel</code>, when storing output vs time).</p><p><strong>Implementation</strong></p><p><code>data::DataFrame</code> contains columns of same type as <code>FieldRecord.records</code> for each Variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L85-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.save_jld2" href="#PALEOmodel.OutputWriters.save_jld2"><code>PALEOmodel.OutputWriters.save_jld2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_jld2(output::OutputMemory, filename)</code></pre><p>Save to <code>filename</code> in JLD2 format (NB: filename must either have no extension or have extension <code>.jld2</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L476-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.load_jld2!" href="#PALEOmodel.OutputWriters.load_jld2!"><code>PALEOmodel.OutputWriters.load_jld2!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">load_jld2!(output::OutputMemory, filename)</code></pre><p>Load from <code>filename</code> in JLD2 format, replacing any existing content in <code>output</code>. (NB: filename must either have no extension or have extension <code>.jld2</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; output = PALEOmodel.OutputWriters.load_jld2!(PALEOmodel.OutputWriters.OutputMemory(), &quot;savedoutput.jld2&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L507-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.initialize!" href="#PALEOmodel.OutputWriters.initialize!"><code>PALEOmodel.OutputWriters.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize!(output::OutputMemory, model, modeldata, nrecords [;rec_coord=:tmodel])</code></pre><p>Initialize from a PALEOboxes::Model, reserving memory for an assumed output dataset of <code>nrecords</code>.</p><p>The default for <code>rec_coord</code> is <code>:tmodel</code>, for a sequence of records following the time evolution of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L558-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.OutputWriters.add_record!" href="#PALEOmodel.OutputWriters.add_record!"><code>PALEOmodel.OutputWriters.add_record!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_record!(output::OutputMemory, model, modeldata, rec_coord)</code></pre><p>Add an output record for current state of <code>model</code> at record coordinate <code>rec_coord</code>. The usual case (set by <a href="#PALEOmodel.OutputWriters.initialize!"><code>initialize!</code></a>) is that the record coordinate is model time <code>tmodel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/OutputWriters.jl#L583-L588">source</a></section></article><h2 id="Plot-output"><a class="docs-heading-anchor" href="#Plot-output">Plot output</a><a id="Plot-output-1"></a><a class="docs-heading-anchor-permalink" href="#Plot-output" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldArray}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldArray}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(fa::FieldArray; kwargs...)</code></pre><p>Plot recipe that plots <code>fa</code>. If <code>fa</code> has a single dimension, this is suitable for a line-like plot, if two dimensions, a heatmap.</p><p><strong>Keywords</strong></p><ul><li><code>swap_xy::Bool=false</code>: true to swap x and y axes </li><li><code>mult_y_coord=1.0</code>: workaround for bugs in Plots.jl heatmap <code>yflip</code> - multiply y coordinate by constant factor.</li><li><code>structfield::Union{Symbol, Nothing}=nothing</code>: use field <code>structfield</code> from a struct-valued array.</li><li><code>map_values=PB.get_total</code>: function to apply to y (for a 1D series) or z (for a 2D heatmap etc) before plotting </li><li><code>labelprefix=&quot;&quot;</code>: prefix for plot label.</li><li><code>labellist=[]</code>: list of labels to override defaults</li><li><code>labelattribute=nothing</code>: FieldArray attribute to use as label</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L195-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.AbstractOutputWriter, Union{AbstractString, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:AbstractString}, NamedTuple}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.AbstractOutputWriter, Union{AbstractString, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:AbstractString}, NamedTuple}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(output::AbstractOutputWriter, vars::Union{AbstractString, Vector{&lt;:AbstractString}}, selectargs::NamedTuple=NamedTuple())</code></pre><p>Plot recipe that calls <code>PB.get_field(output, var)</code>, and passes on to <code>plot(fr::FieldRecord, selectargs)</code></p><p>Additional features:</p><ul><li>if <code>vars</code> is a Vector, create a plot series for each element.</li><li>if <code>var</code> is of form <code>&lt;domain&gt;.&lt;name&gt;.&lt;structfield&gt;</code>, then set <code>structfield</code> to take a single field from a <code>struct</code> Variable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:PALEOmodel.AbstractOutputWriter, Union{AbstractString, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:AbstractString}, NamedTuple}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:PALEOmodel.AbstractOutputWriter, Union{AbstractString, Vector{var&quot;#s27&quot;} where var&quot;#s27&quot;&lt;:AbstractString}, NamedTuple}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(outputs::Vector{&lt;:AbstractOutputWriter}, vars::Union{AbstractString, Vector{&lt;:AbstractString}}, selectargs::NamedTuple=NamedTuple())</code></pre><p>Pass through (ie &quot;broadcast&quot;) each element <code>output</code> of <code>outputs</code> to <code>plot(output::AbstractOutputWriter, vars, selectargs)</code>, adding a <code>labelprefix</code> (index in <code>outputs</code> Vector) to identify each plot series produced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldRecord, NamedTuple}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldRecord, NamedTuple}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(fr::FieldRecord, selectargs::NamedTuple)</code></pre><p>Plot recipe that calls <code>get_array(fr; selectargs...)</code> and passes on to <code>plot(fa::FieldArray)</code>.</p><p>Vector-valued fields in <code>selectargs</code> are broadcasted (generating a separate plot series for each combination)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L175-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:PALEOmodel.FieldArray}" href="#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, Vector{var&quot;#s28&quot;} where var&quot;#s28&quot;&lt;:PALEOmodel.FieldArray}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot(fas::Vector{&lt;:FieldArray}; labelprefix=&quot;&quot;)</code></pre><p>Pass through (ie &quot;broadcast&quot;) each element of <code>fas</code> to <code>plot(fa::FieldArray)</code>, generating one plot series for each.  Adds Vector index to <code>labelprefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L350-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.PlotPager" href="#PALEOmodel.PlotPager"><code>PALEOmodel.PlotPager</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlotPager(layout, [, kwargs=NamedTuple()])</code></pre><p>Accumulate plots into subplots.</p><p><code>layout</code> is supplied to <code>Plots.jl</code> <code>layout</code> keyword, may be an Int or a Tuple (ny, nx), see https://docs.juliaplots.org/latest/</p><p>Optional <code>kwargs</code> provides keyword arguments supplied to <code>plot</code> (eg (legend<em>background</em>color=nothing, ) to set all subplot legends to transparent backgrounds)</p><p><strong>Usage</strong></p><pre><code class="nohighlight hljs">julia&gt; pp = PlotPager((2,2))  # 4 panels per screen (2 down, 2 across)
julia&gt; pp(plot(1:3))  # Accumulate
julia&gt; pp(:skip, plot(1:4), plot(1:5), plot(1:6))  # add multiple panels in one command
julia&gt; pp(:newpage) # flush any partial screen and start new page (NB: always add this at end of a sequence!)</code></pre><p><strong>Commands</strong></p><ul><li><code>pp(p)</code>: accumulate plot p</li><li><code>pp(:skip)</code>: leave a blank panel</li><li><code>pp(:newpage)</code>: fill with blank panels and start new page</li><li><code>pp(p1, p2, ...)</code>: multiple plots/commands in one call </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/PlotRecipes.jl#L9-L32">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Plot.test_heatmap_edges</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Analyze-reaction-network"><a class="docs-heading-anchor" href="#Analyze-reaction-network">Analyze reaction network</a><a id="Analyze-reaction-network-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze-reaction-network" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ReactionNetwork" href="#PALEOmodel.ReactionNetwork"><code>PALEOmodel.ReactionNetwork</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ReactionNetwork</code></pre><p>Functions to analyize a PALEOboxes.Model that contains a reaction network</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/31ee8a0ec8a5c87024ea4341542f3d09e25696e2/src/ReactionNetwork.jl#L1-L5">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HOWTOsmallnegativevalues/">« Managing small and negative values</a><a class="docs-footer-nextpage" href="../References/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 6 May 2022 11:57">Friday 6 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
