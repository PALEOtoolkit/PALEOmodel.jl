var documenterSearchIndex = {"docs":
[{"location":"PALEOmodelSolvers/#PALEOmodel-solvers","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"","category":"section"},{"location":"PALEOmodelSolvers/#Initialization","page":"PALEOmodel solvers","title":"Initialization","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"initialize!\nset_statevar_from_output!","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.initialize!","page":"PALEOmodel solvers","title":"PALEOmodel.initialize!","text":"initialize!(model::PB.Model; kwargs...) -> (initial_state::Vector, modeldata::PB.ModelData)\n\nInitialize model and return:\n\nan initial_state Vector\na modeldata struct containing the model arrays.\n\nInitialising the state vector\n\nWith default arguments, the model state variables are initialised to the values defined in the .yaml configuration file used to create the model.\n\nThe optional pickup_output argument can be used to provide an OutputWriter instance with pickup data to initialise from, using set_statevar_from_output!. This is applied afer the default initialisation, hence can be used to (re)initialise a subset of model state variables.\n\nDataTypes for model arrays\n\nWith default arguments, the model arrays use Float64 as the element type. The eltype keyword argument can be used to specify a different Julia DataType, eg for use with automatic differentiation.  Per-Variable DataType can be specified by using the :datatype Variable attribute to specify String-valued tags, in combination with the eltypemap keyword argument to  provide a Dict of tag names => DataTypes. \n\nThread safety\n\nA thread-safe model can be created with threadsafe=true (to create Atomic Variables for those Variables with attribute :atomic==true), and supplying method_barrier (a thread barrier to add to ReactionMethod dispatch lists between dependency-free groups)\n\nKeyword summary\n\npickup_output=nothing: OutputWriter with pickup data to initialise from\neltype::Type=Float64: default data type to use for model arrays\neltypemap=Dict{String, DataType}(): Dict of data types to look up Variable :datatype attribute\nthreadsafe=false: true to create thread safe Atomic Variables where Variable attribute :atomic==true\nmethod_barrier=nothing: thread barrier to add to dispatch lists if threadsafe==true\nexpect_hostdep_varnames=[\"global.tforce\"]: non-state-Variable host-dependent Variable names expected\nSolverView_all=true: true to create modeldata.solver_view_all\ncreate_dispatchlists_all=true: true to create modeldata.dispatchlists_all\ngenerated_dispatch=true: true to autogenerate code for modeldata.dispatchlists_all (fast dispatch, slow compile)\n\n\n\n\n\n[deprecated] initialize!(run::Run; kwargs...) -> (initial_state::Vector, modeldata::PB.ModelData)\n\nCall initialize! on run.model.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.set_statevar_from_output!","page":"PALEOmodel solvers","title":"PALEOmodel.set_statevar_from_output!","text":"set_statevar_from_output!(modeldata, output::AbstractOutputWriter) -> initial_state\n\nInitialize model state Variables from last record in output\n\nNB: modeldata must contain solver_view_all\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#DifferentialEquations-solvers","page":"PALEOmodel solvers","title":"DifferentialEquations solvers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"Wrappers for the Julia DifferentialEquations package ODE and DAE solvers.  These are usually appropriate for smaller biogeochemical models.","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"NB: see Managing small and negative values for best practices and common issues when using ODE or DAE solvers.","category":"page"},{"location":"PALEOmodelSolvers/#High-level-wrappers","page":"PALEOmodel solvers","title":"High level wrappers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODE","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"integrate\nintegrateDAE","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.integrate","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.integrate","text":"integrate(run, initial_state, modeldata, tspan [; kwargs...] ) -> sol::SciMLBase.ODESolution\nintegrateForwardDiff(run, initial_state, modeldata, tspan [;kwargs...]) -> sol::SciMLBase.ODESolution\n\nIntegrate run.model as an ODE or as a DAE with constant mass matrix, and write to outputwriter\n\nProvides a wrapper around the Julia SciML DifferentialEquations  package ODE solvers, with PALEO-specific additional setup. Keyword arguments alg and solvekwargs are passed through to the DifferentialEquations solve method.\n\nintegrateForwardDiff sets keyword arguments jac_ad=:ForwardDiffSparse, alg=Sundials.CVODE_BDF(linear_solver=:KLU) to use the Julia ForwardDiff package to provide the Jacobian with forward-mode automatic differentiation and automatic sparsity detection.\n\nImplementation\n\nFollows the SciML standard pattern:\n\nCreate ODEfunction\nCreate SciMLBase.ODEproblem\nCall SciMLBase.solve\n\nand then \n\nCall print_sol_stats\nCall calc_output_sol! to recalculate model fields at timesteps used\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct\ntspan:  (tstart, tstop) integration start and stop times\n\nKeywords\n\nalg=Sundials.CVODE_BDF():  ODE algorithm to use, passed through to DifferentialEquations.jl solve method. The default is appropriate for a stiff system of equations (common in biogeochemical models), see https://diffeq.sciml.ai/dev/solvers/ode_solve/ for other options.\nsolvekwargs=NamedTuple(): NamedTuple of keyword arguments passed through to DifferentialEquations.jl solve  (eg to set abstol, reltol, saveat,  see https://diffeq.sciml.ai/dev/basics/common_solver_opts/)\noutputwriter=run.output: PALEOmodel.AbstractOutputWriter instance to hold output\njac_ad=:NoJacobian: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)\njac_ad_t_sparsity=tspan[1]: model time at which to calculate Jacobian sparsity pattern\nsteadystate=false: true to use DifferentialEquations.jl SteadyStateProblem (not recommended, see PALEOmodel.SteadyState.steadystate).\nBLAS_num_threads=1: number of LinearAlgebra.BLAS threads to use\ngenerated_dispatch=true: true to autogenerate code (fast solve, slow compile)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.integrateDAE","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.integrateDAE","text":"integrateDAE(run, initial_state, modeldata, tspan [; kwargs...]) -> sol::SciMLBase.DAESolution\nintegrateDAEForwardDiff(run, initial_state, modeldata, tspan [; kwargs...]) -> sol::SciMLBase.DAESolution\n\nIntegrate run.model as a DAE and copy output to outputwriter.\n\nProvides a wrapper around the Julia SciML DifferentialEquations  package DAE solvers, with PALEO-specific additional setup. Keyword arguments alg and solvekwargs are passed through to the DifferentialEquations solve method.\n\nintegrateDAEForwardDiff sets keyword arguments jac_ad=:ForwardDiffSparse, alg=Sundials.CVODE_BDF(linear_solver=:KLU) to use the Julia ForwardDiff package to provide the Jacobian with forward-mode automatic differentiation and automatic sparsity detection.\n\nImplementation\n\nFollows the SciML standard pattern:\n\nCreate DAEfunction\nCall get_inconsistent_initial_deriv -> initial_deriv\nCreate SciMLBase.DAEproblem\nCall SciMLBase.solve\n\nand then \n\nCall print_sol_stats\nCall calc_output_sol! to recalculate model fields at timesteps used\n\nKeywords\n\nAs integrate, with defaults:\n\nalg=Sundials.IDA() (integrateDAE)\nalg=Sundials.IDA(linear_solver=:KLU) (integrateDAEForwardDiff)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Low-level-functions","page":"PALEOmodel solvers","title":"Low level functions","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODE","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"ODEfunction\n\nDAEfunction\nget_inconsistent_initial_deriv\n\nprint_sol_stats\ncalc_output_sol!","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.ODEfunction","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.ODEfunction","text":"ODEfunction(model::PB.Model, modeldata [; kwargs]) -> SciMLBase.ODEFunction\n\nContruct SciML ODEfunction https://diffeq.sciml.ai/latest/ with PALEO-specific setup\n\nKeyword arguments are required to generate a Jacobian function (using automatic differentation).\n\nKeywords\n\njac_ad=:NoJacobian: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)\ninitial_state::AbstractVector: initial state vector\njac_ad_t_sparsity::Float64: model time at which to calculate Jacobian sparsity pattern\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.DAEfunction","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.DAEfunction","text":"DAEfunction(model::PB.Model, modeldata [; kwargs]) -> SciMLBase.DAEFunction\n\nContruct SciML DAEfunction https://diffeq.sciml.ai/latest/ with PALEO-specific setup\n\nKeyword arguments are required to generate a Jacobian function (using automatic differentation).\n\nKeywords\n\njac_ad=:NoJacobian: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)\ninitial_state::AbstractVector: initial state vector\njac_ad_t_sparsity::Float64: model time at which to calculate Jacobian sparsity pattern\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.get_inconsistent_initial_deriv","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.get_inconsistent_initial_deriv","text":"get_inconsistent_initial_deriv(\n    initial_state, modeldata, initial_t, differential_vars, modeldae::SolverFunctions.ModelDAE\n) -> initial_deriv\n\nCreate (inconsistent) initial_deriv for a DAE problem: ODE variables are consistent, DAE variables set to zero  ie rely on DAE solver to find them\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.print_sol_stats","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.print_sol_stats","text":"print_sol_stats(sol::SciMLBase.ODESolution)\nprint_sol_stats(sol::SciMLBase.DAESolution)\nprint_sol_stats(sol::SciMLBase.NonlinearSolution)\n\nPrint solution statistics\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODE.calc_output_sol!","page":"PALEOmodel solvers","title":"PALEOmodel.ODE.calc_output_sol!","text":"calc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.ODESolution, tspan, initial_state, modeldata)\ncalc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.DAESolution, tspan, initial_state, modeldata)\ncalc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.NonlinearSolution, tspan, initial_state, modeldata)\ncalc_output_sol!(outputwriter, model::PB.Model, tsoln::AbstractVector, soln::AbstractVector,  modeldata)\n\nIterate through solution and recalculate model fields (functions of state variables and time) and store in outputwriter.\n\nArguments\n\noutputwriter::PALEOmodel.AbstractOutputWriter: container for output\nmodel::PB.Model used to calculate solution\nsol: SciML solution object\ntspan:  (tstart, tstop) integration start and stop times\ninitial_state::AbstractVector: initial state vector\ntsoln::AbstractVector:  solution times\nsoln::AbstractVector: solution state variables\nmodeldata::PB.Modeldata: ModelData struct\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)","page":"PALEOmodel solvers","title":"Steady-state solvers (Julia NLsolve based)","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.SteadyState","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"steadystate\nsteadystate_ptc\nsteadystate_ptc_splitdae\nConservationCallback","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SteadyState.steadystate","page":"PALEOmodel solvers","title":"PALEOmodel.SteadyState.steadystate","text":"steadystate(run, initial_state, modeldata, tss [; kwargs...] )\nsteadystateForwardDiff(run, initial_state, modeldata, tss [; kwargs...] )\n\nFind steady-state solution (using NLsolve.jl package)  and write to outputwriter (two records are written, for initial_state and the steady-state solution).\n\nsteadystateForwardDiff has default keyword argument jac_ad=:ForwardDiffSparse to use automatic differentiation for sparse Jacobian.\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntss:  (yr) model tforce time for steady state solution\n\nOptional Keywords\n\noutputwriter::PALEOmodel.AbstractOutputWriter=run.output: container to hold output\ninitial_time=-1.0:  tmodel to write for first output record\nsolvekwargs=NamedTuple(): NamedTuple of keyword arguments passed through to NLsolve.jl  (eg to set method, ftol, iteration, show_trace, store_trace).\njac_ad: :NoJacobian, :ForwardDiffSparse, :ForwardDiff\nuse_norm=false: not supported (must be false)\nBLAS_num_threads=1: number of LinearAlgebra.BLAS threads to use\ngenerated_dispatch=true: true to use autogenerated code (fast solve, slow compile)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.SteadyState.steadystate_ptc","page":"PALEOmodel solvers","title":"PALEOmodel.SteadyState.steadystate_ptc","text":"steadystate_ptc(run, initial_state, modeldata, tspan, deltat_initial; kwargs...) \nsteadystate_ptcForwardDiff(run, initial_state, modeldata, tspan, deltat_initial; kwargs...)\n\nFind steady-state solution and write to outputwriter, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps from tspan[1] to tspan[2] and NLsolve.jl as the non-linear solver.\n\nsteadystate_ptcForwardDiff has keyword argument default jac_ad=:ForwardDiffSparse to use automatic differentiation for  sparse Jacobian.\n\nEach pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton's method.\n\nInitial pseudo-timestep Δt is deltat_initial, this is multiplied by deltat_fac for the next iteration until pseudo-time tss_max is reached. If an iteration fails, Δt is divided by deltat_fac and the iteration retried. NB: this is a very naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate deltat_fac for each problem.\n\nSolver options to pass through to the outer NLsolve nonlinear solver are set by solvekwargs\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntspan: Vector or Tuple with (initial_time, final_time)\ndeltat_initial: initial pseudo-timestep\n\nKeywords\n\ndeltat_fac=2.0: factor to increase pseudo-timestep on success\ntss_output=Float64[]: Vector of model times at which to save output (empty Vector to save all output timesteps)\noutputwriter=run.output: output destination\nsolvekwargs=NamedTuple(): arguments to pass through to NLsolve\nmax_iter=1000: maximum number of PTC iterations\nmax_failed_iter=20: maximum number of iterations that make no progress (either fail, or no change in solution) before exiting\njac_ad=:NoJacobian: AD Jacobian to use (:NoJacobian or :ForwardDiff)\nrequest_adchunksize=10: ForwardDiff chunk size to request.\njac_cellranges=modeldata.cellranges_all: CellRanges to use for Jacobian calculation (eg to restrict to an approximate Jacobian by using a cellrange with a non-default operatorID: in this case, Variables that are not calculated but needed for the Jacobian should set the transfer_jacobian attribute so that they will be copied)\nstep_callbacks=[]: vector of callback functions to follow a successful step [step_callback(sol.zero, tss, deltat, model, modeldata)],  eg to project solution onto invariant manifold (Shampine, 1999)\nenforce_noneg=false: fail pseudo-timesteps that generate negative values for state variables.\nverbose=false: true for detailed output\nBLAS_num_threads=1: restrict threads used by Julia BLAS (likely irrelevant if using sparse Jacobian?)\ngenerated_dispatch=true: true to use autogenerated code (fast solve, slower compile)\n[Deprecated: use_norm=false: not supported (must be false)]\n[Deprecated: sol_min: now has no effect, replace with  solve_kwargs=(project_region! = PALEOmodel.SolverFunctions.ClampAll!(sol_min, sol_max), )]\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.SteadyState.steadystate_ptc_splitdae","page":"PALEOmodel solvers","title":"PALEOmodel.SteadyState.steadystate_ptc_splitdae","text":"steadystate_ptc_splitdae(run, initial_state, modeldata, tspan, deltat_initial; kwargs...)\n\nAs steadystate_ptc, with an inner Newton solve for per-cell algebraic constraints (eg quasi-steady-state reaction intermediates).\n\nKeywords (in common with steadystate_ptc)\n\ndeltat_fac\ntss_output\noutputwriter\nsolvekwargs\nmax_iter\nmax_failed_iter\nrequest_adchunksize\njac_cellranges\nenforce_noneg\nverbose\n\nKeywords (additional to steadystate_ptc)\n\noperatorID_inner=3: operatorID for Reactions to run for inner solve (typically all reservoirs and chemical reactions)\ntransfer_inner_vars=[\"tmid\", \"volume\", \"ntotal\", \"Abox\"]: Variables not calculated by operatorID_inner that need to be copied for  inner solve (additional to those with transfer_jacobian set).\ninner_jac_ad::Symbol=:ForwardDiff: form of automatic differentiation to use for Jacobian for inner NonlinearNewton.solve solver (options :ForwardDiff, :ForwardDiffSparse)\ninner_start::Symbol=:current: start value for inner solve (options :initial, :current, :zero)\ninner_kwargs::NamedTuple=(verbose=0, miniters=2, reltol=1e-12, jac_constant=true, project_region=identity): keywords for inner  NonlinearNewton.solve solver.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.SteadyState.ConservationCallback","page":"PALEOmodel solvers","title":"PALEOmodel.SteadyState.ConservationCallback","text":"ConservationCallback(\n    tmodel_start::Float64 # earliest model time to apply correction\n    content_name::String # variable with a total of X\n    flux_name::String  # variable with a corresponding boundary flux of X\n    reservoir_total_name::String  # total for reservoir to apply correction to\n    reservoir_statevar_name::String # state variable for reservoir to apply correction to\n    reservoir_fac::Float64  # stoichiometric factor (1 / moles of quantity X per reservoir molecule)\n) -> ccb\n\nProvides a callback function with signature\n\nccb(state, tmodel, deltat, model, modeldata)\n\nthat modifies modeldata arrays and state to enforce budget conservation.\n\nGeneral principle is to project the solution onto an invariant manifold (modifying state variables), as discussed in (Shampine, 1999) \n\nExample\n\nconservation_callback_H = Callbacks.ConservationCallback(\n    tmodel_start=1e5,\n    content_name=\"global.content_H_atmocean\",\n    flux_name=\"global.total_H\",\n    reservoir_total_name=\"atm.CH4_total\", # \"atm.H2_total\",\n    reservoir_statevar_name=\"atm.CH4_mr\", # \"atm.H2_mr\",\n    reservoir_fac=0.25 # 0.5, # H per reservoir molecule\n)\n\nthen add to eg `steadystate_ptc_splitdae` with `step_callbacks` keyword argument:\n\n    step_callbacks = [conservation_callback_H]\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"Function objects to project Newton steps into valid regions:","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.SolverFunctions","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"ClampAll!\nClampAll","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ClampAll!","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ClampAll!","text":"ca! = ClampAll!(minvalue, maxvalue)\nca!(v)\n\nFunction object to clamp all values in Vector v to specified range using clamp!(v, minvalue, maxvalue) (in-place, mutating version)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ClampAll","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ClampAll","text":"ca = ClampAll(minvalue, maxvalue)\nca(v) -> v\n\nFunction object to clamp all values in Vector v to specified range using clamp.(v, minvalue, maxvalue) (out-of-place version)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#Steady-state-solvers-(Sundials-Kinsol-based):","page":"PALEOmodel solvers","title":"Steady-state solvers (Sundials Kinsol based):","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.SteadyStateKinsol","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"steadystate_ptc","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SteadyStateKinsol.steadystate_ptc","page":"PALEOmodel solvers","title":"PALEOmodel.SteadyStateKinsol.steadystate_ptc","text":"steadystate_ptc(run, initial_state, modeldata, tspan, deltat_initial; \n    [,deltat_fac=2.0] [,tss_output] [,outputwriter] [,createkwargs] [,solvekwargs]\n    [, use_jac_preconditioner] [,jac_cellranges] [, use_directional_ad] [, directional_ad_eltypestomap]\n    [,verbose] [,  BLAS_num_threads]\n)\n\nFind steady-state solution and write to outputwriter, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps and PALEOmodel.Kinsol as the non-linear solver.\n\nEach pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton's method (preconditioned Newton-Krylov, with the Jacobian as preconditioner)\n\nInitial pseudo-timestep Δt is deltat_initial, this is multiplied by deltat_fac for the next iteration until pseudo-time tss_max is reached. If an iteration fails, Δt is divided by deltat_fac and the iteration retried.\n\nNB: this is a very naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate deltat_fac for each problem.\n\nSolver PALEOmodel.Kinsol options are set by arguments createkwargs (passed through to PALEOmodel.Kinsol.kin_create) and solvekwargs (passed through to PALEOmodel.Kinsol.kin_solve).\n\nIf use_jac_ad_preconditioner is true, the AD Jacobian is used as preconditioner. The preconditioner (Jacobian) calculation can be modified by jac_cellranges, to specify a operatorIDs  so use only a subset of Reactions in order to  calculate an approximate Jacobian to use as the preconditioner.\n\nIf use_directional_ad is true, the Jacobian-vector product will be calculated using automatic differentiation (instead of  the default finite difference approximation).  directional_ad_eltypestomap can be used to specify Variable :datatype tags (strings) that should be mapped to the AD directional derivative datatype hence included in the AD directional derivative.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"Kinsol\nKinsol.kin_create\nKinsol.kin_solve","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.Kinsol","page":"PALEOmodel solvers","title":"PALEOmodel.Kinsol","text":"Kinsol\n\nMinimal Julia wrapper for the Sundials kinsol nonlinear system solver https://computing.llnl.gov/projects/sundials/kinsol\n\nThis closely follows the native C interface, as documented in the Kinsol manual, with conversion to-from native Julia types.\n\nThe main user-facing functions are Kinsol.kin_create and Kinsol.kin_solve.\n\n\n\n\n\n","category":"module"},{"location":"PALEOmodelSolvers/#PALEOmodel.Kinsol.kin_create","page":"PALEOmodel solvers","title":"PALEOmodel.Kinsol.kin_create","text":"kin_create(f, y0 [; kwargs...]) -> kin\n\nCreate and return a kinsol solver context kin, which can then be passed to kin_solve\n\nArguments\n\nf: Function of form f(fy::Vector{Float64}, y::Vector{Float64}, userdata)\ny0::Vector template Vector of initial values (used only to define problem dimension)\n\nKeywords\n\nuserdata: optional user data, passed through to f etc.\nlinear_solver: linear solver to use (only partially implemented, supports :Dense, :Band, :FGMRES)\npsolvefun: optional preconditioner solver function (for :FGMRES)\npsetupfun: optional preconditioner setup function\njvfun: optional Jacobian*vector  function (for :FGMRES)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.Kinsol.kin_solve","page":"PALEOmodel solvers","title":"PALEOmodel.Kinsol.kin_solve","text":"kin_solve(\n    kin, y0::Vector;\n    [strategy] [, fnormtol] [, mxiter] [, print_level] [,y_scale] [, f_scale] [, noInitSetup]\n) -> (y, kin_stats)\n\nSolve nonlinear system using kinsol solver context kin (created by kin_create) and initial conditions y0. Returns solution y and solver statistics kinstats. kinstats.returnflag indicates success/failure.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Fixed-timestep-solvers","page":"PALEOmodel solvers","title":"Fixed timestep solvers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODEfixed","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"PALEO native fixed-timestep, first-order Euler integrators, with split-explicit and multi-threaded options. These are usually appropriate for larger biogeochemical models (eg ocean models using GCM transport matrices).","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"The low-level timestepping is provided by integrateFixed and integrateFixedthreads,  with higher-level wrappers for common options provided by integrateEuler etc.","category":"page"},{"location":"PALEOmodelSolvers/#High-level-wrappers-2","page":"PALEOmodel solvers","title":"High-level wrappers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODEfixed","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"integrateEuler\nintegrateSplitEuler\nintegrateEulerthreads\nintegrateSplitEulerthreads","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateEuler","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateEuler","text":"integrateEuler(run, initial_state, modeldata, tspan, Δt [; kwargs])\n\nIntegrate run.model from initial_state using first-order Euler with fixed timestep.\n\nCalls integrateFixed\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntspan:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times\nΔt: (yr) fixed timestep\n\nKeywords\n\noutputwriter::PALEOmodel.AbstractOutputWriter=run.output: container to write model output to\nreport_interval=1000: number of timesteps between progress update to console\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateSplitEuler","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateSplitEuler","text":"integrateSplitEuler(run, initial_state, modeldata, tspan, Δt_outer, n_inner;\n                        cellranges_outer, cellranges_inner,\n                        [,outputwriter])\n\nIntegrate run.model representing:\n\nfracdSdt =  f_outer(t S) + f_inner(t S)\n\nusing split first-order Euler with Δt_outer for f_outer and a shorter timestep Δt_outer/n_inner for f_inner.\n\nf_outer is defined by calling PALEOboxes.do_deriv with cellranges_outer hence corresponds to those Reactions with operatorID of cellranges_outer. f_inner is defined by calling PALEOboxes.do_deriv with cellranges_inner hence corresponds to those Reactions with operatorID of cellranges_inner.\n\nNB: the combined time derivative is written to outputwriter.\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntspan:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times\nΔt_outer: (yr) fixed outer timestep \nn_inner: number of inner timesteps per outer timestep\n\nKeywords\n\ncellranges_outer: Vector of CellRange with operatorID defining f_outer.\ncellranges_inner: Vector of CellRange with operatorID defining f_inner.\noutputwriter::PALEOmodel.AbstractOutputWriter=run.output: container to write model output to\nreport_interval=1000: number of outer timesteps between progress update to console\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateEulerthreads","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateEulerthreads","text":"integrateEulerthreads(run, initial_state, modeldata, cellranges, tspan, Δt;\n    outputwriter=run.output, report_interval=1000)\n\nIntegrate run.model using first-order Euler with fixed timestep Δt, with tiling over multiple threads.\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ncellranges::Vector{Vector{AbstractCellRange}}: Vector of Vector-of-cellranges, one per thread (so length(cellranges) == Threads.nthreads).\ntspan:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times\nΔt: (yr) fixed outer timestep\n\nKeywords\n\noutputwriter::PALEOmodel.AbstractOutputWriter=run.output: container to write model output to\nreport_interval=1000: number of outer timesteps between progress update to console\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateSplitEulerthreads","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateSplitEulerthreads","text":"integrateSplitEulerthreads(run, initial_state, modeldata, tspan, Δt_outer, n_inner::Int; \n                            cellranges_outer, cellranges_inner, [,outputwriter] [, report_interval])\n\nIntegrate run.model using split first-order Euler with Δt_outer for f_outer and a shorter timestep Δt_outer/n_inner for f_inner.\n\nf_outer is defined by calling PALEOboxes.do_deriv with cellrange_outer hence corresponds to those Reactions with operatorID of cellrange_outer.  f_inner is defined by calling PALEOboxes.do_deriv with cellrange_inner hence corresponds to those Reactions with operatorID of cellrange_inner.\n\nUses Threads.nthreads threads and tiling described by cellranges_inner and cellranges_outer (each a Vector of Vector{AbstractCellRange}, one per thread).\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntspan:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times\nΔt_outer: (yr) fixed outer timestep \nn_inner: number of inner timesteps per outer timestep (0 for non-split solver)\n\nKeywords\n\ncellranges_outer::Vector{Vector{AbstractCellRange}}: Vector of list-of-cellranges, one list per thread (so length(cellranges) == Threads.nthreads), with operatorID defining f_outer.\ncellranges_inner::Vector{Vector{AbstractCellRange}}: As cellranges_outer, with operatorID defining f_inner.\noutputwriter::PALEOmodel.AbstractOutputWriter=run.output: container to write model output to\nreport_interval=1000: number of outer timesteps between progress update to console\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODELocalIMEX","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"integrateLocalIMEXEuler","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler","page":"PALEOmodel solvers","title":"PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler","text":"integrateLocalIMEXEuler(run, initial_state, modeldata, tspan, Δt_outer [; kwargs...])\n\nIntegrate run.model representing:\n\nfracdSdt =  f_outer(t S) + f_inner(t S)\n\nusing first-order Euler with Δt_outer for f_outer and implicit first-order Euler for f_inner, where f_inner is local (within-cell, ie no transport), for a single Domain, and uses only StateExplicit and Deriv variables.\n\nf_outer is defined by calling PALEOboxes.do_deriv with cellranges_outer hence corresponds to those Reactions with operatorID of cellranges_outer.  f_inner is defined by calling PALEOboxes.do_deriv with cellrange_inner hence corresponds to those Reactions with operatorID of cellrange_inner.\n\nNB: the combined time derivative is written to outputwriter.\n\nArguments\n\nrun::Run: struct with model::PB.Model to integrate and output field\ninitial_state::AbstractVector: initial state vector\nmodeldata::Modeldata: ModelData struct with appropriate element type for forward model\ntspan:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times\nΔt_outer: (yr) fixed timestep\n\nKeywords\n\ncellranges_outer: Vector of CellRange with operatorID defining f_outer.\ncellrange_inner: A single CellRange with operatorID defining f_inner.\nexclude_var_nameroots: State variables that are modified by Reactions in cellrange_inner, but not needed to find implicit solution (ie reaction rates etc don't depend on them).\n[outputwriter=run.output: PALEOmodel.AbstractOutputWriter instance to write model output to]\n[report_interval=1000: number of outer timesteps between progress update to console]\n[Lnorm_inf_max=1e-3:  normalized error tolerance for implicit solution]\n[niter_max=10]: maximum number of Newton iterations\n[request_adchunksize=4]: request ForwardDiff AD chunk size (will be restricted to an upper limit)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Low-level-timesteppers","page":"PALEOmodel solvers","title":"Low-level timesteppers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ODEfixed","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"integrateFixed\nintegrateFixedthreads","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateFixed","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateFixed","text":"integrateFixed(run, initial_state, modeldata, tspan, Δt_outer;\n            timesteppers, outputwriter=run.output, report_interval=1000)\n\nFixed timestep integration, with time step implemented by timesteppers,\n\n`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ...], ...]`\n\nWhere timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.ODEfixed.integrateFixedthreads","page":"PALEOmodel solvers","title":"PALEOmodel.ODEfixed.integrateFixedthreads","text":"integrateFixedthreads(run, initial_state, modeldata, tspan, Δt_outer;\n            timesteppers, outputwriter=run.output, report_interval=1000)\n\nFixed timestep integration using Threads.nthreads() threads, with time step implemented by timesteppers,\n\n`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ... (1 per thread)], ...]`\n\nWhere timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier).\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Thread-barriers","page":"PALEOmodel solvers","title":"Thread barriers","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.ThreadBarriers","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"ThreadBarrierAtomic\nThreadBarrierCond","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.ThreadBarriers.ThreadBarrierAtomic","page":"PALEOmodel solvers","title":"PALEOmodel.ThreadBarriers.ThreadBarrierAtomic","text":"ThreadBarrierAtomic\n\nThread synchronisation barrier for Threads.nthreads() Julia Threads.  Uses a pair of Atomic variables to avoid the need for locks. Resets so can be reused.\n\nExample:\n\nbarrier = ThreadBarrierAtomic(\"my barrier\")    \nThreads.@threads for t in 1:Threads.nthreads()  \n    # do stuff\n    \n    wait_barrier(barrier)  # blocks until all threads reach this point\n\n    # do more stuff\nend\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.ThreadBarriers.ThreadBarrierCond","page":"PALEOmodel solvers","title":"PALEOmodel.ThreadBarriers.ThreadBarrierCond","text":"ThreadBarrierCond\n\nThread synchronisation barrier for Threads.nthreads() Julia Threads using Condition variable and associated lock. Resets so can be reused. \n\nNB: testing on Julia 1.6 suggests this is slow. \n\nExample:\n\nbarrier = ThreadBarrierCond(\"my barrier\")    \nThreads.@threads for t in 1:Threads.nthreads()  \n    # do stuff\n    \n    wait_barrier(barrier)  # blocks until all threads reach this point\n\n    # do more stuff\nend\n\nImplementation:\n\nUses a condition variable (with associated lock) and a counter. See eg http://web.eecs.utk.edu/~huangj/cs360/360/notes/CondVar/lecture.html\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#Variable-aggregation","page":"PALEOmodel solvers","title":"Variable aggregation","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"A SolverView uses a collection of PALEOboxes.VariableAggregators to assemble model state Variables and associated time derivatives into contiguous Vectors, for the convenience of standard numerical ODE / DAE solvers.  See Mathematical formulation of the reaction-transport problem. ","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"SolverView\nset_default_solver_view!\ncopy_norm!\nset_statevar!\nget_statevar_sms!","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverView","page":"PALEOmodel solvers","title":"PALEOmodel.SolverView","text":"SolverView(model, modeldata, arrays_idx; [verbose=true]) \nSolverView(model, modeldata, cellranges; [verbose=false], [indices_from_cellranges=true])\n\nProvides a view on the whole or some part of the Model for a numerical solver.\n\nContains PALEOboxes.VariableAggregators for a subset of spatial locations   (Domains, indices within spatial Domains) and Variables, with:     - ODE paired stateexplicit (S) and stateexplicit_deriv (dS/dt), where dS/dt = F(S).     - Implicit-ODE paired total (T) and total_deriv (dT/dt), where dT(S)/dt = F(T(S)) with         total a function of explicit and implicit state Variables statexplicit and state (S).     - Algebraic constraints (C), where C(S) = 0 with C a function of explicit and implicit state Variables statexplicit and state (S),\n\nThe number of total + number of constraint Variables must equal the number of implicit state Variables.\n\nOptional access methods provide an ODE/DAE solver view with composite statevar and statevar_sms,where:\n\n- `statevar` is a concatenation of `stateexplicit` and `state` ([`set_statevar!`](@ref))\n- `statevar_sms` is a concatenation of `stateexplicit_deriv`, `total_deriv`, `constraints` ([`get_statevar_sms!`](@ref))\n\nConstructors create a SolverView for the entire model from modeldata array set arrays_idx,  or for a subset of Model Variables defined by the Domains and operatorIDs of cellranges. \n\nKeywords\n\nindices_from_cellranges=true: true to restrict to the index ranges from cellranges, false to just use cellranges to define Domains\n\nand take the whole of each Domain.\n\nhostdep_all=true: true to include host dependent not-state Variables from all Domains\nreallocate_hostdep_eltype=Float64: a data type to reallocate hostdep Variables eg to replace any\n\nAD types.\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.set_default_solver_view!","page":"PALEOmodel solvers","title":"PALEOmodel.set_default_solver_view!","text":"set_default_solver_view!(model, modeldata)\n\n(Optional, used to set modeldata.solver_view_all to a SolverView) for the whole model, and set modeldata.hostdep_data to any non-state-variable host dependent Variables)\n\nreallocate_hostdep_eltype a data type to reallocate hostdep_data eg to replace any AD types.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.copy_norm!","page":"PALEOmodel solvers","title":"PALEOmodel.copy_norm!","text":"copy norm values from state variable etc data\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.set_statevar!","page":"PALEOmodel solvers","title":"PALEOmodel.set_statevar!","text":"set_statevar!(sv::SolverView, u)\n\nSet combined stateexplicit, state variables from u\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#PALEOmodel.get_statevar_sms!","page":"PALEOmodel solvers","title":"PALEOmodel.get_statevar_sms!","text":"get_statevar_sms!(du, sv::SolverView)\n\nGet combined derivatives and constraints, eg for an ODE solver\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelSolvers/#Function-objects","page":"PALEOmodel solvers","title":"Function objects","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"CurrentModule = PALEOmodel.SolverFunctions","category":"page"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"Function objects are callable structs with function signatures required by DifferentialEquations or other solvers to calculate model time derivative, Jacobian, etc. They combine variable aggregation (using PALEOboxes.VariableAggregators or PALEOmodel.SolverView) with corresponding Reaction dispatch lists.","category":"page"},{"location":"PALEOmodelSolvers/#ODE-function-objects","page":"PALEOmodel solvers","title":"ODE function objects","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"ModelODE\nModelODE_at_t\nJacODEForwardDiffDense\nJacODEForwardDiffSparse\nJacODE_at_t","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ModelODE","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ModelODE","text":"ModelODE(\n    modeldata; \n    solver_view=modeldata.solver_view_all,\n    dispatchlists=modeldata.dispatchlists_all\n) -> f::ModelODE\n\nFunction object to calculate model time derivative and adapt to SciML ODE solver interface\n\nCall as f(du,u, p, t)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ModelODE_at_t","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ModelODE_at_t","text":"ModelODE_at_t\n\nFunction object to calculate model derivative at t, eg to adapt to ForwardDiff or NLsolve interface\n\nCalculates F = du/dt(t)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.JacODEForwardDiffDense","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.JacODEForwardDiffDense","text":"JacODEForwardDiffDense(\n    modeldata; \n    solver_view=modeldata.solver_view_all,\n    dispatchlists=modeldata.dispatchlists_all,\n    du_template, \n    jacconf,\n) -> jac::JacODEForwardDiffDense\n\nFunction object to calculate dense Jacobian in form required for SciML ODE solver.\n\nsolver_view, dispatchlists should correspond to modeldata, which should have the appropriate element type for ForwardDiff Dual numbers.\n\nCall as jac(J, u, p, t)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.JacODEForwardDiffSparse","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.JacODEForwardDiffSparse","text":"JacODEForwardDiffSparse(\n    modeldata; \n    solver_view=modeldata.solver_view_all,\n    dispatchlists=modeldata.dispatchlists_all,\n    du_template,\n    throw_on_nan, \n    jac_cache,\n) -> jac::JacODEForwardDiffSparse\n\nFunction object to calculate sparse Jacobian in form required for SciML ODE solver.\n\nsolver_view, dispatchlists should correspond to modeldata, which should have the appropriate element type for ForwardDiff Dual numbers.\n\nCall as jac(J, u, p, t)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.JacODE_at_t","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.JacODE_at_t","text":"JacODE_at_t\n\nFunction object to calculate ODE model Jacobian at t, eg to adapt to NLsolve interface\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#DAE-function-objects","page":"PALEOmodel solvers","title":"DAE function objects","text":"","category":"section"},{"location":"PALEOmodelSolvers/","page":"PALEOmodel solvers","title":"PALEOmodel solvers","text":"ModelDAE\nJacDAE\nTotalForwardDiff\nImplicitForwardDiffDense\nImplicitForwardDiffSparse","category":"page"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ModelDAE","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ModelDAE","text":"ModelDAE\n\nFunction object to calculate model residual G and adapt to SciML DAE solver interface.\n\nIf using Total variables, odeimplicit should be an ImplicitForwardDiffDense or ImplicitForwardDiffSparse, otherwise nothing.\n\nProvides function signature:\n\n(fdae::ModelDAE)(G, dsdt, s, p, t)\n\nwhere residual G(dsdt,s,p,t) is:\n\n-dsdt + F(s)  (for ODE-like state Variables s with time derivative F given explicitly in terms of s)\nF(s) (for algebraic constraints)\nduds*dsdt + F(s, u(s)) (for Total variables u that depend implicitly on state Variables s)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.JacDAE","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.JacDAE","text":"JacDAE\n\nFunction object to calculate Jacobian in form required for SciML DAE solver\n\nodejac should be a JacODEForwardDiffDense or JacODEForwardDiffSparse\n\nIf using Total variables, odeimplicit should be an ImplicitForwardDiffDense or ImplicitForwardDiffSparse, otherwise nothing.\n\nProvides function signature:\n\n(jdae::JacDAE)(J, dsdt, s, p, γ, t)\n\nCalculates Jacobian J in the form γ*dG/d(dsdt) + dG/ds where γ is given by the solver\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.TotalForwardDiff","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.TotalForwardDiff","text":"TotalForwardDiff\n\nCalculate Total variables, with function signature required by ForwardDiff\n\nCalling:\n\nset_t!(tfd::TotalForwardDiff, t)\ntfd(T, u)\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ImplicitForwardDiffDense","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ImplicitForwardDiffDense","text":"ImplicitForwardDiffDense\n\nCalculate dT/dS required for a model containing implicit Total variables, using ForwardDiff and dense AD\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelSolvers/#PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse","page":"PALEOmodel solvers","title":"PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse","text":"ImplicitForwardDiffSparse\n\nCalculate dT/dS required for a model containing implicit Total variables, using ForwardDiff and  sparse AD with SparseDiffTools.forwarddiff_color_jacobian!\n\n\n\n\n\n","category":"type"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"HOWTOshowmodelandoutput/#Displaying-model-configuration-and-output-from-the-Julia-REPL","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The examples below assume the COPSE Reloaded example has been run from the Julia REPL.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Displaying-large-tables-in-Julia","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying large tables in Julia","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Several PALEO commands produce large tables.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"There are several options to display these:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Julia in VS code provides the julia> vscodedisplay(<some table>) command. As of Jan 2022 this is now usually the best option.\nUse julia> show(<some table>, allcols=true, allrows=true) to show as text in the REPL. \nUse julia> CSV.write(\"some_table.csv\", <some table>) to save as a CSV file and open in Excel etc.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Display-model-configuration","page":"Displaying model configuration and output from the Julia REPL","title":"Display model configuration","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/#Display-parameters:","page":"Displaying model configuration and output from the Julia REPL","title":"Display parameters:","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Examples illustrating the use of PALEOboxes.show_parameters:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To show parameters for every Reaction in the model:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> vscodedisplay(PB.show_parameters(run.model)) # show in VS code table viewer\njulia> show(PB.show_parameters(run.model), allrows=true) # show as text in REPL \njulia> import CSV\njulia> CSV.write(\"parameters.csv\", PB.show_parameters(run.model)) # save as CSV for Excel etc","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"This illustrates the modularised model structure, with:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Domains global, atm, land, ocean, oceansurface, oceanfloor, sedcrust containing forcings and biogeochemical Reactions, with Parameters attached to each Reaction.\nAdditional Domains fluxAtoLand, fluxLandtoSedCrust, fluxOceanBurial, fluxOceanfloor, fluxRtoOcean, fluxSedCrusttoAOcean containing flux coupler Reactions.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To show parameters for a single Reaction:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> rct_temp_global = PB.get_reaction(run.model, \"global\", \"temp_global\")\njulia> PB.show_parameters(rct_temp_global)    # GEOCARB temperature function parameters","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The Julia Type of rct_temp_global PALEOreactions.Global.Temperature.ReactionGlobalTemperatureBerner usually makes it possible to guess the location in the source code PALEOreactions/global/Temperature.jl.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Display-Variables:","page":"Displaying model configuration and output from the Julia REPL","title":"Display Variables:","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/#Show-Variables-in-the-model:","page":"Displaying model configuration and output from the Julia REPL","title":"Show Variables in the model:","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To list all Variables in the model:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> vscodedisplay(PB.show_variables(run.model)) # VS code only","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To list full information for all Variables in the model (including Variable linking and current values):","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> vscodedisplay(PB.show_variables(run.model, modeldata=modeldata, showlinks=true))","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"This illustrates the modularized model structure, with:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Domains global, atm, land, ocean, oceansurface, oceanfloor, sedcrust containing Variables linked to Reactions (either property-dependencies or target-contributors pairs).\nAdditional Domains fluxAtoLand, fluxLandtoSedCrust, fluxOceanBurial, fluxOceanfloor, fluxRtoOcean, fluxSedCrusttoAOcean containing target-contributor pairs representing inter-module fluxes.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"It is also possible to show Variables for a specific Domain eg:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> domain_land = PB.get_domain(run.model, \"land\")\njulia> vscodedisplay(PB.show_variables(domain_land))","category":"page"},{"location":"HOWTOshowmodelandoutput/#Show-linkage-for-a-single-Domain-or-ReactionMethod-Variable","page":"Displaying model configuration and output from the Julia REPL","title":"Show linkage for a single Domain or ReactionMethod Variable","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To show linkage of a single VariableDomain in Domain \"atm\" with name \"pO2PAL\":","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> PB.show_links(PB.get_variable(run.model, \"atm.pO2PAL\"))","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To show linkage of a ReactionMethod Variable with localname \"pO2PAL\", Reaction \"ocean_copse\" in Domain \"ocean\":","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> PB.show_links(PB.get_reaction_variables(run.model, \"ocean\", \"ocean_copse\", \"pO2PAL\"))","category":"page"},{"location":"HOWTOshowmodelandoutput/#Display-model-output","page":"Displaying model configuration and output from the Julia REPL","title":"Display model output","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Model output is stored in a PALEOmodel.AbstractOutputWriter object, which is available as run.output, ie the output field of the default PALEOmodel.Run instance created by the COPSE_reloaded_reloaded.jl script.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The default PALEOmodel.OutputWriters.OutputMemory stores model output in memory, by Domain:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> run.output  # shows Domains","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To show metadata for all Variables in the output:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> vscodedisplay(PB.show_variables(run.output)) # VS code only\njulia> vscodedisplay(PB.show_variables(run.output, \"land\")) # just the land Domain","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Output from a list of Variables or for each Domain can be exported to a Julia DataFrame:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> # display data for a list of Variables as a Table\njulia> vscodedisplay(PB.get_table(run.output, [\"atm.tmodel\", \"atm.pCO2PAL\", \"fluxOceanBurial.flux_total_P\"]))\n\njulia> # display data for every Variable in the 'atm' Domain as a Table\njulia> vscodedisplay(PB.get_table(run.output, \"atm\"))\n\njulia> # show a subset of output variables from the 'atm' Domain\njulia> PB.get_table(run.output, \"atm\")[!, [:tmodel, :pCO2atm, :pCO2PAL]]","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Data from each Variable can be accessed as a PALEOmodel.FieldArray (a Python-xarray like struct with named dimensions and coordinates):","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> pCO2atm = PALEOmodel.get_array(run.output, \"atm.pCO2atm\")\njulia> pCO2atm.values # raw data Array\njulia> pCO2atm.dims[1] # pCO2 is a scalar Variable with one dimension `records` which has a coordinate `tmodel`\njulia> pCO2atm.dims[1].coords[1].values # raw values for model time (`tmodel`)","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Raw data arrays can also be accessed as Julia Vectors using get_data:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> pCO2atm_raw = PB.get_data(run.output, \"atm.pCO2atm\")  # raw data Array\njulia> tmodel_raw = PB.get_data(run.output, \"atm.tmodel\") # raw data Array","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"(here these are the values and coordinate of the pCO2atm PALEOmodel.FieldArray, ie pCO2atm_raw == pCO2atm.values and tmodel_raw == pCO2atm.dims[1].coords[1].values).","category":"page"},{"location":"HOWTOshowmodelandoutput/#Plot-model-output","page":"Displaying model configuration and output from the Julia REPL","title":"Plot model output","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The output can be plotted using the Julia Plots.jl package, see Plotting output. Plot recipes are defined for PALEOmodel.FieldArray, so output data can be plotted directly using the plot command:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> using Plots\njulia> plot(run.output, \"atm.pCO2atm\")  # plot output variable as a single command\njulia> plot(pCO2atm) # a PALEOmodel.FieldArray can be plotted\njulia> plot!(tmodel_raw, pCO2atm_raw, label=\"some raw data\") # overlay data from standard Julia Vectors","category":"page"},{"location":"HOWTOshowmodelandoutput/#Spatial-or-wavelength-dependent-output","page":"Displaying model configuration and output from the Julia REPL","title":"Spatial or wavelength-dependent output","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To analyze spatial or eg wavelength-dependent output (eg time series from a 1D column or 3D general circulation model, or quantities that are a function of wavelength or frequency), PALEOmodel.get_array takes an additional selectargs::NamedTuple argument to take 1D or 2D slices from the spatial, spectral and timeseries data. The PALEOmodel.FieldArray returned includes default coordinates to plot column (1D) and heatmap (2D) data, these can be overridden by supplying the optional coords keyword argument.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Examples-for-a-column-based-model","page":"Displaying model configuration and output from the Julia REPL","title":"Examples for a column-based model","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Visualisation of spatial and wavelength-dependent output from the PALEOdev.jl ozone photochemistry example (a single 1D atmospheric column):","category":"page"},{"location":"HOWTOshowmodelandoutput/#D-column-data","page":"Displaying model configuration and output from the Julia REPL","title":"1D column data","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> plot(title=\"O3 mixing ratio\", output, \"atm.O3_mr\", (tmodel=[0.0, 0.1, 1.0, 10.0, 100.0, 1000.0], column=1),\n            swap_xy=true, xscale=:log10, labelattribute=:filter_records) # plots O3 vs default height coordinate","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Here the optional labelattribute=:filter_records keyword argument is used to generate plot labels from the :filter_records FieldArray attribute, which contains the tmodel values used to select the timeseries records.  The plot recipe expands the Vector-valued tmodel argument to overlay a sequence of plots.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"This is equivalent to first creating and then plotting a sequence of FieldArray objects:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> O3_mr = PALEOmodel.get_array(run.output, \"atm.O3_mr\", (tmodel=0.0, column=1))\njulia> plot(title=\"O3 mixing ratio\", O3_mr, swap_xy=true, xscale=:log10, labelattribute=:filter_records)\njulia> O3_mr = PALEOmodel.get_array(run.output, \"atm.O3_mr\", (tmodel=0.1, column=1))\njulia> plot!(O3_mr, swap_xy=true, labelattribute=:filter_records)","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The default height coordinate from the model grid can be replaced using the optional coords keyword argument, eg","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> plot(title=\"O3 mixing ratio\", output, \"atm.O3_mr\", (tmodel=[0.0, 0.1, 1.0, 10.0, 100.0, 1000.0], column=1),\n            coords=[\"p\"=>(\"atm.pmid\", \"atm.plower\", \"atm.pupper\")],\n            swap_xy=true, xscale=:log10, yflip=true, yscale=:log10, labelattribute=:filter_records) # plots O3 vs pressure","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The current values in the modeldata struct can also be plotted using the same syntax, eg","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> plot(title=\"O2, O3 mixing ratios\", modeldata, [\"atm.O2_mr\", \"atm.O3_mr\"], (column=1,),\n            swap_xy=true, xscale=:log10) # plot current value of O2, O3 vs height","category":"page"},{"location":"HOWTOshowmodelandoutput/#Wavelength-dependent-data","page":"Displaying model configuration and output from the Julia REPL","title":"Wavelength-dependent data","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> plot(title=\"direct transmittance\", output, [\"atm.direct_trans\"], (tmodel=1e12, column=1, cell=[1, 80]),\n            ylabel=\"fraction\", labelattribute=:filter_region) # plots vs wavelength","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Here tmodel=1e12 selects the last model time output, and column=1, cell=[1, 80] selects the top and bottom cells within the first (only) 1D column. The labelattribute=:filter_region keyword argument is used to generate plot labels from the :filter_region FieldArray attribute, which contains the column and cell values used to select the spatial region.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Examples-for-a-3D-GCM-based-model","page":"Displaying model configuration and output from the Julia REPL","title":"Examples for a 3D GCM-based model","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Visualisation of spatial output from the 3D GENIE transport-matrix example (PALEOdev.jl repository)","category":"page"},{"location":"HOWTOshowmodelandoutput/#Horizontal-slices-across-levels","page":"Displaying model configuration and output from the Julia REPL","title":"Horizontal slices across levels","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> heatmap(run.output, \"ocean.O2_conc\", (tmodel=1e12, k=1), swap_xy=true)","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Here k=1 selects a horizontal level corresponding to model grid cells with index k=1, which is the ocean surface in the GENIE grid.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Vertical-section-at-constant-longitude","page":"Displaying model configuration and output from the Julia REPL","title":"Vertical section at constant longitude","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> heatmap(run.output, \"ocean.O2_conc\", (tmodel=1e12, i=10), swap_xy=true, mult_y_coord=-1.0)","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Here i=10 selects a section at longitude corresponding to model grid cells with index i=10.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Save-and-load-output","page":"Displaying model configuration and output from the Julia REPL","title":"Save and load output","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"Model output can be saved and loaded using the PALEOmodel.OutputWriters.save_netcdf and PALEOmodel.OutputWriters.load_netcdf! methods.","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"The PALEOmodel.OutputWriters.save_jld2 and PALEOmodel.OutputWriters.load_jld2! methods are still available as these files will not remain compatible with future PALEO versions.","category":"page"},{"location":"HOWTOshowmodelandoutput/#Export-output-to-a-CSV-file","page":"Displaying model configuration and output from the Julia REPL","title":"Export output to a CSV file","text":"","category":"section"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"To write Model output from a single Domain to a CSV file:","category":"page"},{"location":"HOWTOshowmodelandoutput/","page":"Displaying model configuration and output from the Julia REPL","title":"Displaying model configuration and output from the Julia REPL","text":"julia> import CSV\njulia> CSV.write(\"copse_land.csv\", PB.get_table(run.output, \"land\")) # all Variables from land Domain\njulia> CSV.write(\"copse_atm.csv\", PB.get_table(run.output, \"atm\")[!, [:tmodel, :pCO2atm, :pO2atm]]) # subset of Variables from atm Domain","category":"page"},{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"MathematicalFormulation/#Mathematical-formulation-of-the-reaction-transport-problem","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"","category":"section"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"The PALEO models define various special cases of a general DAE problem (these can be combined, providing the number  of implicit state variables S_impl is equal to the number of algebraic constraints G plus the number of total variables U):","category":"page"},{"location":"MathematicalFormulation/#Explicit-ODE","page":"Mathematical formulation of the reaction-transport problem","title":"Explicit ODE","text":"","category":"section"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"The time derivative of explicit state variables S_explicit (a subset of all state variables S_all) are an explicit function of time t:","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"fracdS_explicitdt = F(S_all t)","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"where explicit state variables S_explicit are identified by PALEO attribute :vfunction = PALEOboxes.VF_StateExplicit and paired time derivatives F by :vfunction = PALEOboxes.VF_Deriv along with the naming convention <statevarname>, <statevarname>_sms.","category":"page"},{"location":"MathematicalFormulation/#Algebraic-constraints","page":"Mathematical formulation of the reaction-transport problem","title":"Algebraic constraints","text":"","category":"section"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"State variables S_impl (a subset of all state variables S_all) are defined by algebraic constraints G:","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"0 = G(S_all t)","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"where implicit state variables S_impl are identified by PALEO attribute :vfunction = PALEOboxes.VF_State and algebraic constaints G by :vfunction = PALEOboxes.VF_Constraint (these are not paired).","category":"page"},{"location":"MathematicalFormulation/#ODE-with-variable-substitution","page":"Mathematical formulation of the reaction-transport problem","title":"ODE with variable substitution","text":"","category":"section"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"State variables S_impl (a subset of all state variables S_all) are defined the time evolution of total variables U(S_all) (this case is common in biogeochemistry where the total variables U represent conserved chemical elements, and the state variables eg primary species):","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"fracdU(S_all)dt = F(U(S_all) t)","category":"page"},{"location":"MathematicalFormulation/","page":"Mathematical formulation of the reaction-transport problem","title":"Mathematical formulation of the reaction-transport problem","text":"where total variables U are identified by PALEO attribute :vfunction = PALEOboxes.VF_Total and paired time derivatives F by :vfunction = PALEOboxes.VF_Deriv along with the naming convention <totalvarname>, <totalvarname>_sms, and implicit state variables S_impl are identified by PALEO attribute :vfunction = PALEOboxes.VF_State.","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel-output","page":"PALEOmodel output","title":"PALEOmodel output","text":"","category":"section"},{"location":"PALEOmodelOutput/#Run","page":"PALEOmodel output","title":"Run","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"Run","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.Run","page":"PALEOmodel output","title":"PALEOmodel.Run","text":"Run\n\nContainer for model and output.\n\nFields\n\nmodel::Union{Nothing, PB.Model}: The model instance.\noutput::Union{Nothing, AbstractOutputWriter}: model output\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#Output","page":"PALEOmodel output","title":"Output","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"PALEO model output is accumulated into a container such as an OutputMemory instance that implements the AbstractOutputWriter interface.","category":"page"},{"location":"PALEOmodelOutput/#AbstractOutputWriter-interface","page":"PALEOmodel output","title":"AbstractOutputWriter interface","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"AbstractOutputWriter","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.AbstractOutputWriter","page":"PALEOmodel output","title":"PALEOmodel.AbstractOutputWriter","text":"AbstractOutputWriter\n\nInterface implemented by containers for PALEO model output.\n\nImplementations should define methods for:\n\nWriting output\n\ninitialize!\nadd_record!\n\nModifying output\n\nPB.add_field!\n\nQuerying output\n\nPB.get_table\nPB.show_variables\nPB.has_variable\n\nAccessing output data\n\nPALEOmodel.get_array\nPB.get_field\nPB.get_mesh\nPB.get_data\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel.OutputWriters","category":"page"},{"location":"PALEOmodelOutput/#Writing-output","page":"PALEOmodel output","title":"Writing output","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"initialize!\nadd_record!","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.initialize!","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.initialize!","text":"initialize!(\n    output::PALEOmodel.AbstractOutputWriter, model, modeldata, nrecords \n    [;coords_record=:tmodel] [coords_record_units=\"year\"]\n)\n\nInitialize from a PALEOboxes::Model, reserving memory for an assumed output dataset of nrecords.\n\nThe default for coords_record is :tmodel, for a sequence of records following the time evolution of the model.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.add_record!","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.add_record!","text":"add_record!(output::PALEOmodel.AbstractOutputWriter, model, modeldata, rec_coord)\n\nAdd an output record for current state of model at record coordinate rec_coord. The usual case (set by initialize!) is that the record coordinate is model time tmodel.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#Modifying-output","page":"PALEOmodel output","title":"Modifying output","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"PB.add_field!(output::PALEOmodel.AbstractOutputWriter, fr::PALEOmodel.FieldRecord) ","category":"page"},{"location":"PALEOmodelOutput/#PALEOboxes.add_field!-Tuple{PALEOmodel.AbstractOutputWriter, PALEOmodel.FieldRecord}","page":"PALEOmodel output","title":"PALEOboxes.add_field!","text":"add_field!(output::PALEOmodel.AbstractOutputWriter, fr::PALEOmodel.FieldRecord)\n\nAdd PALEOmodel.FieldRecord fr to output, with Domain and name defined by fr.attributes[:var_domain] and fr.attributes[:var_name].\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#Querying-output","page":"PALEOmodel output","title":"Querying output","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"PB.get_table(output::PALEOmodel.AbstractOutputWriter, domainname::AbstractString)\nPB.show_variables(output::PALEOmodel.AbstractOutputWriter)\nPB.has_variable(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString)","category":"page"},{"location":"PALEOmodelOutput/#PALEOboxes.get_table-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOboxes.get_table","text":"get_table(output::PALEOmodel.AbstractOutputWriter, domainname::AbstractString) -> Table\nget_table(output::PALEOmodel.AbstractOutputWriter, varnames::Vector{<:AbstractString}) -> Table\n\nReturn a DataFrame with raw model output data for Domain domainname, or for Variables varnames\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#PALEOboxes.show_variables-Tuple{PALEOmodel.AbstractOutputWriter}","page":"PALEOmodel output","title":"PALEOboxes.show_variables","text":"show_variables(output::PALEOmodel.AbstractOutputWriter; kwargs...) -> Table\nshow_variables(output::PALEOmodel.AbstractOutputWriter, domainname::AbstractString; kwargs...) -> Table\n\nKeywords:\n\nattributes=[:units, :vfunction, :space, :field_data, :description]: Variable attributes to include\nfilter = attrb->true: function to filter by Variable attributes. Example: filter=attrb->attrb[:vfunction]!=PB.VF_Undefined to show state Variables and derivatives.\n\nExamples:\n\njulia> vscodedisplay(PB.show_variables(run.output))  # show all output Variables in VS code table viewer\njulia> vscodedisplay(PB.show_variables(run.output, [\"atm.pCO2PAL\", \"fluxOceanBurial.flux_P_total\"]))  # show subset of output Variables in VS code table viewer\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#PALEOboxes.has_variable-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOboxes.has_variable","text":"has_variable(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString)  -> Bool\n\nTrue if model output contains Variable varname.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#Accessing-output-data","page":"PALEOmodel output","title":"Accessing output data","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"PALEOmodel.get_array(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString; kwargs...)\nPB.get_field(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString)\nPB.get_data(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString; records=nothing)\nPB.get_mesh(output::PALEOmodel.AbstractOutputWriter, domainname::AbstractString)","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.get_array-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOmodel.get_array","text":"get_array(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString [, allselectargs::NamedTuple] [; coords::AbstractVector]) -> FieldArray\nget_array(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString; allselectargs...) -> FieldArray\n\nReturn a PALEOmodel.FieldArray containing data values and any attached coordinates, for the  PALEOmodel.FieldRecord for varname, and records and spatial region defined by selectargs\n\nIf coords is not supplied, equivalent to PALEOmodel.get_array(PB.get_field(output, varname), allselectargs).\n\nOptional argument coords can be used to supply plot coordinates from Variable in output, to replace any default coordinates. Format is a Vector of Pairs of \"coordname\"=>(\"varname1\", \"var_name2\", ...)\n\nExample: to replace a 1D column default pressure coordinate with a z coordinate:\n\ncoords=[\"z\"=>(\"atm.zmid\", \"atm.zlower\", \"atm.zupper\")]\n\nNB: the coordinates will be generated by applying selectargs, so the supplied coordinate Variables must have the same dimensionality as vars.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#PALEOboxes.get_field-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOboxes.get_field","text":"get_field(output::PALEOmodel.AbstractOutputWriter, varname::AbstractString) -> FieldRecord\n\nReturn the PALEOmodel.FieldRecord for varname.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#PALEOboxes.get_data-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOboxes.get_data","text":"get_data(output::PALEOmodel.AbstractOutputWriter, varname; records=nothing) -> values\n\nGet Variable varname raw data array, optionally restricting to records\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#PALEOboxes.get_mesh-Tuple{PALEOmodel.AbstractOutputWriter, AbstractString}","page":"PALEOmodel output","title":"PALEOboxes.get_mesh","text":"get_mesh(output::PALEOmodel.AbstractOutputWriter, domainname::AbstractString) -> grid::Union{AbstractMesh, Nothing}\n\nReturn grid for output Domain domainname.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"FieldRecord","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.FieldRecord","page":"PALEOmodel output","title":"PALEOmodel.FieldRecord","text":"FieldRecord{D <: AbstractData, S <: AbstractSpace, V, N, M, R}\nFieldRecord(\n    f::PB.Field{D, S, V, N, M}, attributes; \n    coords_record, \n    sizehint::Union{Nothing, Int}=nothing\n) -> fr\n\nA series of records::R each containing the values from a PALEOboxes.Field{D, S, N, V, M}.\n\nA coords_record may be attached to provide a coordinate (eg model time) corresponding to records.\n\nImplementation\n\nFields with array values are stored in records as a Vector of arrays. Fields with single values (field_single_element true) are stored as a Vector of eltype(Field.values). \n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#OutputMemory","page":"PALEOmodel output","title":"OutputMemory","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel.OutputWriters","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"OutputMemory\nOutputMemoryDomain","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.OutputMemory","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.OutputMemory","text":"OutputMemory\n\nIn-memory container for model output, organized by model Domains.\n\nImplements the PALEOmodel.AbstractOutputWriter interface, with additional methods save_netcdf and load_netcdf! to save and load data.\n\nImplementation\n\nField domains::Dict{String, OutputMemoryDomain} contains per-Domain model output.\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.OutputMemoryDomain","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.OutputMemoryDomain","text":"OutputMemoryDomain\n\nIn-memory model output, for one model Domain.\n\nIncludes an additional coords_record (usually :tmodel, when storing output vs time).\n\nImplementation\n\ndata::DataFrame contains columns of same type as FieldRecord.records for each Variable.\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"save_netcdf\nload_netcdf!\nsave_jld2\nload_jld2!","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.save_netcdf","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.save_netcdf","text":"save_netcdf(output::OutputMemory, filename; kwargs...)\n\nSave to filename in netcdf4 format (NB: filename must either have no extension or have extension .nc)\n\nNotes on structure of netcdf output\n\nEach PALEO Domain is written to a netcdf4 group. These can be read into a Python xarray using the group=<domainname> argument to open_dataset.\nIsotope-valued variables (field_data = PB.IsotopeLinear) are written with an extra isotopelinear netCDF dimension, containing the variable total and delta.\nAny '/' characters in PALEO variables are substited for '%' in the netcdf name.\n\nKeyword arguments\n\ncheck_ext::Bool = true: check that filename ends in \".nc\"\nadd_coordinates::Bool = false: true to attempt to add CF convention coords to variables (experimental, doesn't look that useful)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.load_netcdf!","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.load_netcdf!","text":"load_netcdf!(output::OutputMemory, filename)\n\nLoad from filename in netCDF format, replacing any existing content in output. (NB: filename must either have no extension or have extension .nc).\n\nExample\n\njulia> output = PALEOmodel.OutputWriters.load_netcdf!(PALEOmodel.OutputWriters.OutputMemory(), \"savedoutput.nc\")\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.save_jld2","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.save_jld2","text":"save_jld2(output::OutputMemory, filename)\n\nDeprecated - use save_netcdf\n\nSave to filename in JLD2 format (NB: filename must either have no extension or have extension .jld2)\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.OutputWriters.load_jld2!","page":"PALEOmodel output","title":"PALEOmodel.OutputWriters.load_jld2!","text":"load_jld2!(output::OutputMemory, filename)\n\nLoad from filename in JLD2 format, replacing any existing content in output. (NB: filename must either have no extension or have extension .jld2).\n\nExample\n\njulia> output = PALEOmodel.OutputWriters.load_jld2!(PALEOmodel.OutputWriters.OutputMemory(), \"savedoutput.jld2\")\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#Field-Array","page":"PALEOmodel output","title":"Field Array","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"FieldArray provides a generic array type with named dimensions PALEOboxes.NamedDimension and optional coordinates PALEOboxes.FixedCoord for processing of model output.","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"FieldArray\nget_array(f::PB.Field{D, PB.ScalarSpace, V, N, M}; attributes=nothing) where {D, V, N, M}","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.FieldArray","page":"PALEOmodel output","title":"PALEOmodel.FieldArray","text":"FieldArray\n\nA generic xarray-like or  IRIS-like  Array with named dimensions and optional coordinates.\n\nNB: this aims to be simple and generic, not efficient !!! Intended for representing model output, not for numerically-intensive calculations.\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#PALEOmodel.get_array-Union{Tuple{PALEOboxes.Field{D, PALEOboxes.ScalarSpace, V, N, M}}, Tuple{M}, Tuple{N}, Tuple{V}, Tuple{D}} where {D, V, N, M}","page":"PALEOmodel output","title":"PALEOmodel.get_array","text":"get_array(f::Field [, selectargs::NamedTuple]; [attributes=nothing]) -> FieldArray\n\nReturn a FieldArray containing f::Field data values and any attached coordinates, for the spatial region defined by selectargs.\n\nAvailable selectargs depend on the grid f.mesh, and  are passed to PB.Grids.get_region.\n\nattributes (if present) are added to FieldArray\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#Plotting-output","page":"PALEOmodel output","title":"Plotting output","text":"","category":"section"},{"location":"PALEOmodelOutput/#Plot-recipes","page":"PALEOmodel output","title":"Plot recipes","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"Plotting using the Julia Plots.jl package is implemented by plot recipes that enable plotting of PALEO data types using the plot command.","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"The general principles are that:","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"Data is extracted from model output into FieldArrays with attached coordinates\nVector-valued arguments are \"broadcast\" to allow multiple line plot series to be overlaid in a single plot panel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"RecipesBase.apply_recipe(::Dict{Symbol, Any}, output::AbstractOutputWriter, vars::Union{AbstractString, Vector{<:AbstractString}}, selectargs::NamedTuple)\nRecipesBase.apply_recipe(::Dict{Symbol, Any}, fr::FieldRecord, selectargs::NamedTuple)\nRecipesBase.apply_recipe(::Dict{Symbol, Any}, fa::FieldArray)","category":"page"},{"location":"PALEOmodelOutput/#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.AbstractOutputWriter, Union{AbstractString, Vector{var\"#s8\"} where var\"#s8\"<:AbstractString}, NamedTuple}","page":"PALEOmodel output","title":"RecipesBase.apply_recipe","text":"plot(output::AbstractOutputWriter, vars::Union{AbstractString, Vector{<:AbstractString}} [, selectargs::NamedTuple] [; coords::AbstractVector])\nheatmap(output::AbstractOutputWriter, var::AbstractString [, selectargs::NamedTuple] [; coords::AbstractVector])\nplot(outputs::Vector{<:AbstractOutputWriter}, vars::Union{AbstractString, Vector{<:AbstractString}} [, selectargs::NamedTuple] [; coords::AbstractVector])\n\nplot(modeldata::AbstractModelData, vars::Union{AbstractString, Vector{<:AbstractString}} [, selectargs::NamedTuple] [; coords::AbstractVector])\nheatmap(modeldata::AbstractModelData, var::AbstractString [, selectargs::NamedTuple] [; coords::AbstractVector])\n\nPlot recipe that calls PB.get_field(output, var), and passes on to plot(fr::FieldRecord, selectargs) (see RecipesBase.apply_recipe(::Dict{Symbol, Any}, fr::FieldRecord, selectargs::NamedTuple))\n\nVector-valued outputs or vars are \"broadcast\" to create a plot series for each element. A labelprefix (index in outputs Vector) is added to identify each plot series produced.\n\nIf var is of form <domain>.<name>.<structfield>, then sets the structfield keyword argument to take a single field from a struct Variable.\n\nOptional argument coords can be used to supply plot coordinates from Variable in output. Format is a Vector of Pairs of \"coordname\"=>(\"varname1\", \"var_name2\", ...)\n\nExample: to replace a 1D column default pressure coordinate with a z coordinate:\n\ncoords=[\"z\"=>(\"atm.zmid\", \"atm.zlower\", \"atm.zupper\")]\n\nNB: the coordinates will be generated by applying selectargs, so the supplied coordinate Variables must have the same dimensionality as vars.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldRecord, NamedTuple}","page":"PALEOmodel output","title":"RecipesBase.apply_recipe","text":"plot(fr::FieldRecord, selectargs::NamedTuple)\nheatmap(fr::FieldRecord, selectargs::NamedTuple)\n\nPlot recipe to plot a single FieldRecord\n\nCalls get_array(fr, selectargs) and passes on to plot(fa::FieldArray) (see RecipesBase.apply_recipe(::Dict{Symbol, Any}, fa::FieldArray)).\n\nVector-valued fields in selectargs are \"broadcasted\" (generating a separate plot series for each combination)\n\nOptional argument coords_records can be used to supply plot coordinates from FieldRecords. Format is a Vector of Pairs of \"coordname\"=>(cr1::FieldRecord, cr2::FieldRecord, ...) Example:     coordsrecords=[\"z\"=>(zmid::FieldRecord, zlower::FieldRecord, zupper::FieldRecord)] to replace a 1D column default pressure coordinate with a z coordinate.   NB: the coordinates will be generated by applying selectargs, so the supplied coordinate FieldRecords must have the same dimensionality as fr.\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#RecipesBase.apply_recipe-Tuple{Dict{Symbol, Any}, PALEOmodel.FieldArray}","page":"PALEOmodel output","title":"RecipesBase.apply_recipe","text":"plot(fa::FieldArray; kwargs...)\nheatmap(fa::FieldArray; kwargs...)\nplot(fas::Vector{<:FieldArray}; kwargs...)\n\nPlot recipe that plots a single [FieldArray] or Vector of [FieldArray]. \n\nIf fa has a single dimension, this is suitable for a line-like plot, if two dimensions, a heatmap.\n\nIf fas::Vector is supplied, this is \"broadcast\" generating one plot series for each element,  with the Vector index prepended to labelprefix to identify the plot series (unless overridden by labellist or labelattribute)\n\nKeywords\n\nswap_xy::Bool=false: true to swap x and y axes \nmult_y_coord=1.0: workaround for bugs in Plots.jl heatmap yflip - multiply y coordinate by constant factor.\nstructfield::Union{Symbol, Nothing}=nothing: use field structfield from a struct-valued array.\nmap_values=PB.get_total: function to apply to y (for a 1D series) or z (for a 2D heatmap etc) before plotting \nlabelprefix=\"\": prefix for plot label.\nlabellist=[]: list of labels to override defaults\nlabelattribute=nothing: FieldArray attribute to use as label\n\n\n\n\n\n","category":"method"},{"location":"PALEOmodelOutput/#Assembling-multi-plot-panels","page":"PALEOmodel output","title":"Assembling multi-plot panels","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"PlotPager\nDefaultPlotPager","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.PlotPager","page":"PALEOmodel output","title":"PALEOmodel.PlotPager","text":"PlotPager(layout [, kwargs=NamedTuple()][; displayfunc=(plot, nplot)->display(plot)])\n\nAccumulate plots into subplots.\n\nlayout is supplied to Plots.jl layout keyword, may be an Int or a Tuple (ny, nx), see https://docs.juliaplots.org/latest/.\n\nOptional argument kwargs::NamedTuple provides additional keyword arguments passed through to plot (eg (legend_background_color=nothing, ) to set all subplot legends to transparent backgrounds)\n\nOptional keyword argument displayfunc::(plot, nplot)->display(plot) provides the function used to display a screen of plots, where plot is a Plot object and nplot::Integer is the sequential number of this screen.\n\nUsage\n\njulia> pp = PlotPager((2,2))  # 4 panels per screen (2 down, 2 across)\njulia> pp(plot(1:3))  # Accumulate\njulia> pp(:skip, plot(1:4), plot(1:5), plot(1:6))  # add multiple panels in one command\njulia> pp(:newpage) # flush any partial screen and start new page (NB: always add this at end of a sequence!)\n\njulia> pp = PlotPager((2, 2); displayfunc=(plot, nplot)->savefig(plot, \"plot_$nplot.png\")) # save to file instead of default display\n\nCommands\n\npp(p): accumulate plot p\npp(:skip): leave a blank panel\npp(:newpage): fill with blank panels and start new page\npp(p1, p2, ...): multiple plots/commands in one call \n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#PALEOmodel.DefaultPlotPager","page":"PALEOmodel output","title":"PALEOmodel.DefaultPlotPager","text":"DefaultPlotPager()\n\nDummy version of PlotPager that just calls display for each plot.\n\n\n\n\n\n","category":"type"},{"location":"PALEOmodelOutput/#Analyze-reaction-network","page":"PALEOmodel output","title":"Analyze reaction network","text":"","category":"section"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"ReactionNetwork","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork","text":"ReactionNetwork\n\nFunctions to analyze a PALEOboxes.Model or PALEOmodel output that contains a reaction network\n\nCompiles reaction stoichiometry and rate information from attributes attached to reaction rate variables:\n\nrate_processname::String: a process name (eg \"photolysis\", \"reaction\", ...)\nrate_species::Vector{String} names of reactant and product species\nrate_stoichiometry::Vector{Float64} stoichiometry of reactant and product species\n\n\n\n\n\n","category":"module"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"CurrentModule = PALEOmodel.ReactionNetwork","category":"page"},{"location":"PALEOmodelOutput/","page":"PALEOmodel output","title":"PALEOmodel output","text":"get_ratetable\nget_all_species_ratevars\nget_rates\nget_all_species_ratesummaries\nshow_ratesummaries","category":"page"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork.get_ratetable","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork.get_ratetable","text":"get_ratetable(model, domainname) -> DataFrame\nget_ratetable(output, domainname) -> DataFrame\n\nGet table of rate Variables and reactions\n\nReturns a DataFrame with columns :name, :rate_processname, :rate_species, :rate_stoichiometry\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork.get_all_species_ratevars","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork.get_all_species_ratevars","text":"get_all_species_ratevars(model, domainname) -> OrderedDict(speciesname => [(stoich, ratevarname, processname), ...])\nget_all_species_ratevars(output, domainname) -> OrderedDict(speciesname => [(stoich, ratevarname, processname), ...])\nget_all_species_ratevars(ratetable::DataFrame) -> OrderedDict(speciesname => [(stoich, ratevarname, processname), ...])\n\nGet all species and contributing reaction rate Variable names as Dict of Tuples (stoich, ratevarname, processname) where ratevarname is the name of an output Variable with a reaction rate, stoich is the stoichiometry of that rate applied to species, and processname identifies the nature of the reaction.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork.get_rates","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork.get_rates","text":"get_rates(output, domainname [, outputrec] [, indices] [, scalefac] [, add_equations] [, ratetable_source]) -> DataFrame\n\nGet all reaction rates as column rate_total for domainname from output record outputrec (defaults to last time record), for subset of cells in indices (defaults to whole domain).\n\nSet optional ratetable_source = model to use with older output that doesn't include rate variable attributes.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork.get_all_species_ratesummaries","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork.get_all_species_ratesummaries","text":"get_all_species_ratesummaries(output, domainname [, outputrec] [, indices] [, scalefac] [, ratetable_source]) \n    -> OrderedDict(speciesname => (source, sink, net, source_rxs, sink_rxs))\n\nGet source, sink, net rates and rates of source_rxs and sink_rxs  for all species in domainname from output record outputrec (defaults to last record),  cells in indices (defaults to whole domain),\n\nOptional scalefac to convert units, eg scalefac=1.90834e12 to convert mol m-2 yr-1 to molecule cm-2 s-1\n\nSet optional ratetable_source = model to use with older output that doesn't include rate variable attributes.\n\n\n\n\n\n","category":"function"},{"location":"PALEOmodelOutput/#PALEOmodel.ReactionNetwork.show_ratesummaries","page":"PALEOmodel output","title":"PALEOmodel.ReactionNetwork.show_ratesummaries","text":"show_ratesummaries([io::IO = stdout], ratesummaries [; select_species=[]])\n\nPrint per-species reaction rates from ratesummaries to output stream io (defaults to stdout),  optionally selecting species to print.\n\nExample\n\nratesummaries = PALEOmodel.ReactionNetwork.get_all_species_ratesummaries(model, output, \"atm\")\nPALEOmodel.ReactionNetwork.show_ratesummaries(ratesummaries)\n\n\n\n\n\n","category":"function"},{"location":"#PALEOmodel.jl","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"","category":"section"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"CurrentModule = PALEOmodel","category":"page"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"The PALEOmodel Julia package provides modules to create and solve a standalone PALEOboxes.Model, and to analyse output interactively from the Julia REPL. It implements:","category":"page"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"Numerical solvers (see PALEOmodel solvers)\nData structures to hold model output (see Output)\nOutput plot recipes (see Plotting output)","category":"page"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"For examples and further information see the documentation for other PALEOtoolkit components and repositories:","category":"page"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"PALEOtutorials documentation for tutorial examples.\nPALEOcopse documentation an example of a larger model configuration.\nPALEOboxes documentation, the PALEO framework model coupler.","category":"page"},{"location":"","page":"PALEOmodel.jl","title":"PALEOmodel.jl","text":"PALEO documentation follows the recommendations from https://documentation.divio.com/","category":"page"},{"location":"HOWTOsmallnegativevalues/#Managing-small-and-negative-values","page":"Managing small and negative values","title":"Managing small and negative values","text":"","category":"section"},{"location":"HOWTOsmallnegativevalues/","page":"Managing small and negative values","title":"Managing small and negative values","text":"It is common for biogeochemical reservoirs to both (i) be required to be non-negative, and  (ii) approach zero (eg oxygen below the oxic layer in a sediment). This requires some explicit management to allow the numerical ODE / DAE solvers to operate stably and efficiently.","category":"page"},{"location":"HOWTOsmallnegativevalues/","page":"Managing small and negative values","title":"Managing small and negative values","text":"PALEO follows the recommended best practice for Sundials CVODE and other adaptive solvers (also including those in MATLAB),  which is to allow -ve values within the error tolerance, and set rates to zero when this happens.","category":"page"},{"location":"HOWTOsmallnegativevalues/","page":"Managing small and negative values","title":"Managing small and negative values","text":"This is a FAQ for CVODE, https://computing.llnl.gov/projects/sundials/faq#cvode_negvals,  '... Remember that a small negative value in y returned by CVODE, with magnitude comparable to abstol or less, is equivalent to zero as far as the computation is concerned. .... '.  See (Shampine et al., 2005) for a detailed discussion.","category":"page"},{"location":"HOWTOsmallnegativevalues/","page":"Managing small and negative values","title":"Managing small and negative values","text":"There are three areas that need to be addressed:","category":"page"},{"location":"HOWTOsmallnegativevalues/","page":"Managing small and negative values","title":"Managing small and negative values","text":"When calculating biogeochemical reaction rates that depend on myvar,  use max(myvar, 0.0) or similar everywhere to set rates to zero for -ve values.  Linear transport processes (eg diffusion, flux transport) should transport -ve values to maintain conservation properties.\nSet the abstol solver option to control errors for near-zero values of state Variables, see DifferentialEquations solvers.  The default value will often be too high. In some cases, it may be most efficient to tolerate -ve values, in other cases, it may be most efficient to control errors using a combination of reltol and abstol so that -ve values are not generated. The easiest way to set abstol in PALEO is to use abstol=1e-5*PALEOmodel.get_statevar_norm(modeldata.solver_view_all) to set to a small fraction (here 1e-5, experimentation will be needed) of the state variables' norm_value attributes (these are set in the .yaml configuration file). \nDefend against -ve values when using plots with log scales by explicitly setting an axis lower limit eg ylim=(1e-9, Inf) (without this, the autoscaling will fail and possible produce strange-looking plots eg with inverted axes). See https://docs.juliaplots.org/latest/generated/attributes_axis/","category":"page"}]
}
