<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PALEOmodel solvers · PALEOmodel Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PALEOmodel Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">PALEOmodel.jl</a></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../MathematicalFormulation/">Mathematical formulation of the reaction-transport problem</a></li></ul></li><li><span class="tocitem">HOWTOs</span><ul><li><a class="tocitem" href="../HOWTOshowmodelandoutput/">Displaying model configuration and output from the Julia REPL</a></li><li><a class="tocitem" href="../HOWTOsmallnegativevalues/">Managing small and negative values</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>PALEOmodel solvers</a><ul class="internal"><li><a class="tocitem" href="#Initialization"><span>Initialization</span></a></li><li><a class="tocitem" href="#DifferentialEquations-solvers"><span>DifferentialEquations solvers</span></a></li><li><a class="tocitem" href="#Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)"><span>Steady-state solvers (Julia <code>NLsolve</code> based)</span></a></li><li><a class="tocitem" href="#Steady-state-solvers-(Sundials-Kinsol-based):"><span>Steady-state solvers (Sundials Kinsol based):</span></a></li><li><a class="tocitem" href="#Fixed-timestep-solvers"><span>Fixed timestep solvers</span></a></li><li><a class="tocitem" href="#Variable-aggregation"><span>Variable aggregation</span></a></li><li><a class="tocitem" href="#Function-objects"><span>Function objects</span></a></li></ul></li><li><a class="tocitem" href="../PALEOmodelOutput/">PALEOmodel output</a></li></ul></li><li><a class="tocitem" href="../References/">References</a></li><li><a class="tocitem" href="../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>PALEOmodel solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PALEOmodel solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/main/docs/src/PALEOmodelSolvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PALEOmodel-solvers"><a class="docs-heading-anchor" href="#PALEOmodel-solvers">PALEOmodel solvers</a><a id="PALEOmodel-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#PALEOmodel-solvers" title="Permalink"></a></h1><h2 id="Initialization"><a class="docs-heading-anchor" href="#Initialization">Initialization</a><a id="Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.initialize!" href="#PALEOmodel.initialize!"><code>PALEOmodel.initialize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialize!(model::PB.Model; kwargs...) -&gt; (initial_state::Vector, modeldata::PB.ModelData)</code></pre><p>Initialize <code>model</code> and return:</p><ul><li>an <code>initial_state</code> Vector</li><li>a <code>modeldata</code> struct containing the model arrays.</li></ul><p><strong>Initialising the state vector</strong></p><p>With default arguments, the <code>model</code> state variables are initialised to the values defined in the <code>.yaml</code> configuration file used to create the <code>model</code>.</p><p>The optional <code>pickup_output</code> argument can be used to provide an <code>OutputWriter</code> instance with pickup data to initialise from, using <a href="#PALEOmodel.set_statevar_from_output!"><code>set_statevar_from_output!</code></a>. This is applied afer the default initialisation, hence can be used to (re)initialise a subset of model state variables.</p><p><strong><code>DataType</code>s for model arrays</strong></p><p>With default arguments, the <code>model</code> arrays use <code>Float64</code> as the element type. The <code>eltype</code> keyword argument can be used to specify a different Julia <code>DataType</code>, eg for use with automatic differentiation.  Per-Variable <code>DataType</code> can be specified by using the <code>:datatype</code> Variable attribute to specify <code>String</code>-valued tags, in combination with the <code>eltypemap</code> keyword argument to  provide a <code>Dict</code> of tag names =&gt; <code>DataType</code>s. </p><p><strong>Thread safety</strong></p><p>A thread-safe model can be created with <code>threadsafe=true</code> (to create Atomic Variables for those Variables with attribute <code>:atomic==true</code>), and supplying <code>method_barrier</code> (a thread barrier to add to <code>ReactionMethod</code> dispatch lists between dependency-free groups)</p><p><strong>Keyword summary</strong></p><ul><li><code>pickup_output=nothing</code>: OutputWriter with pickup data to initialise from</li><li><code>eltype::Type=Float64</code>: default data type to use for model arrays</li><li><code>eltypemap=Dict{String, DataType}()</code>: Dict of data types to look up Variable :datatype attribute</li><li><code>threadsafe=false</code>: true to create thread safe Atomic Variables where Variable attribute <code>:atomic==true</code></li><li><code>method_barrier=nothing</code>: thread barrier to add to dispatch lists if <code>threadsafe==true</code></li><li><code>expect_hostdep_varnames=[&quot;global.tforce&quot;]</code>: non-state-Variable host-dependent Variable names expected</li><li><code>SolverView_all=true</code>: <code>true</code> to create <code>modeldata.solver_view_all</code></li><li><code>create_dispatchlists_all=true</code>: <code>true</code> to create <code>modeldata.dispatchlists_all</code></li><li><code>generated_dispatch=true</code>: <code>true</code> to autogenerate code for <code>modeldata.dispatchlists_all</code> (fast dispatch, slow compile)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Initialize.jl#L2-L37">source</a></section><section><div><pre><code class="nohighlight hljs">[deprecated] initialize!(run::Run; kwargs...) -&gt; (initial_state::Vector, modeldata::PB.ModelData)</code></pre><p>Call <code>initialize!</code> on <code>run.model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Run.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.set_statevar_from_output!" href="#PALEOmodel.set_statevar_from_output!"><code>PALEOmodel.set_statevar_from_output!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_statevar_from_output!(modeldata, output::AbstractOutputWriter) -&gt; initial_state</code></pre><p>Initialize model state Variables from last record in <code>output</code></p><p>NB: <code>modeldata</code> must contain <code>solver_view_all</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Initialize.jl#L99-L105">source</a></section></article><h2 id="DifferentialEquations-solvers"><a class="docs-heading-anchor" href="#DifferentialEquations-solvers">DifferentialEquations solvers</a><a id="DifferentialEquations-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations-solvers" title="Permalink"></a></h2><p>Wrappers for the Julia <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations</a> package ODE and DAE solvers.  These are usually appropriate for smaller biogeochemical models.</p><p>NB: see <a href="../HOWTOsmallnegativevalues/#Managing-small-and-negative-values">Managing small and negative values</a> for best practices and common issues when using ODE or DAE solvers.</p><h3 id="High-level-wrappers"><a class="docs-heading-anchor" href="#High-level-wrappers">High level wrappers</a><a id="High-level-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-wrappers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrate" href="#PALEOmodel.ODE.integrate"><code>PALEOmodel.ODE.integrate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrate(run, initial_state, modeldata, tspan [; kwargs...] ) -&gt; sol::SciMLBase.ODESolution
integrateForwardDiff(run, initial_state, modeldata, tspan [;kwargs...]) -&gt; sol::SciMLBase.ODESolution</code></pre><p>Integrate run.model as an ODE or as a DAE with constant mass matrix, and write to <code>outputwriter</code></p><p>Provides a wrapper around the Julia SciML <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations</a>  package ODE solvers, with PALEO-specific additional setup. Keyword arguments <code>alg</code> and <code>solvekwargs</code> are passed through to the <code>DifferentialEquations</code> <code>solve</code> method.</p><p><code>integrateForwardDiff</code> sets keyword arguments <code>jac_ad=:ForwardDiffSparse</code>, <code>alg=Sundials.CVODE_BDF(linear_solver=:KLU)</code> to use the Julia <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a> package to provide the Jacobian with forward-mode automatic differentiation and automatic sparsity detection.</p><p><strong>Implementation</strong></p><p>Follows the SciML standard pattern:</p><ul><li>Create <a href="#PALEOmodel.ODE.ODEfunction"><code>ODEfunction</code></a></li><li>Create <code>SciMLBase.ODEproblem</code></li><li>Call <code>SciMLBase.solve</code></li></ul><p>and then </p><ul><li>Call <a href="#PALEOmodel.ODE.print_sol_stats"><code>print_sol_stats</code></a></li><li>Call <a href="#PALEOmodel.ODE.calc_output_sol!"><code>calc_output_sol!</code></a> to recalculate model fields at timesteps used</li></ul><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct</li><li><code>tspan</code>:  (tstart, tstop) integration start and stop times</li></ul><p><strong>Keywords</strong></p><ul><li><code>alg=Sundials.CVODE_BDF()</code>:  ODE algorithm to use, passed through to DifferentialEquations.jl <code>solve</code> method. The default is appropriate for a stiff system of equations (common in biogeochemical models), see <a href="https://diffeq.sciml.ai/dev/solvers/ode_solve/">https://diffeq.sciml.ai/dev/solvers/ode_solve/</a> for other options.</li><li><code>solvekwargs=NamedTuple()</code>: NamedTuple of keyword arguments passed through to DifferentialEquations.jl <code>solve</code>  (eg to set <code>abstol</code>, <code>reltol</code>, <code>saveat</code>,  see <a href="https://diffeq.sciml.ai/dev/basics/common_solver_opts/">https://diffeq.sciml.ai/dev/basics/common_solver_opts/</a>)</li><li><code>outputwriter=run.output</code>: PALEOmodel.AbstractOutputWriter instance to hold output</li><li><code>jac_ad=:NoJacobian</code>: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)</li><li><code>jac_ad_t_sparsity=tspan[1]</code>: model time at which to calculate Jacobian sparsity pattern</li><li><code>steadystate=false</code>: true to use <code>DifferentialEquations.jl</code> <code>SteadyStateProblem</code> (not recommended, see <a href="#PALEOmodel.SteadyState.steadystate"><code>PALEOmodel.SteadyState.steadystate</code></a>).</li><li><code>BLAS_num_threads=1</code>: number of LinearAlgebra.BLAS threads to use</li><li><code>generated_dispatch=true</code>: <code>true</code> to autogenerate code (fast solve, slow compile)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L119-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.integrateDAE" href="#PALEOmodel.ODE.integrateDAE"><code>PALEOmodel.ODE.integrateDAE</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateDAE(run, initial_state, modeldata, tspan [; kwargs...]) -&gt; sol::SciMLBase.DAESolution
integrateDAEForwardDiff(run, initial_state, modeldata, tspan [; kwargs...]) -&gt; sol::SciMLBase.DAESolution</code></pre><p>Integrate <code>run.model</code> as a DAE and copy output to <code>outputwriter</code>.</p><p>Provides a wrapper around the Julia SciML <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations</a>  package DAE solvers, with PALEO-specific additional setup. Keyword arguments <code>alg</code> and <code>solvekwargs</code> are passed through to the <code>DifferentialEquations</code> <code>solve</code> method.</p><p><code>integrateDAEForwardDiff</code> sets keyword arguments <code>jac_ad=:ForwardDiffSparse</code>, <code>alg=Sundials.CVODE_BDF(linear_solver=:KLU)</code> to use the Julia <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a> package to provide the Jacobian with forward-mode automatic differentiation and automatic sparsity detection.</p><p><strong>Implementation</strong></p><p>Follows the SciML standard pattern:</p><ul><li>Create <a href="#PALEOmodel.ODE.DAEfunction"><code>DAEfunction</code></a></li><li>Call <a href="#PALEOmodel.ODE.get_inconsistent_initial_deriv"><code>get_inconsistent_initial_deriv</code></a> -&gt; <code>initial_deriv</code></li><li>Create <code>SciMLBase.DAEproblem</code></li><li>Call <code>SciMLBase.solve</code></li></ul><p>and then </p><ul><li>Call <a href="#PALEOmodel.ODE.print_sol_stats"><code>print_sol_stats</code></a></li><li>Call <a href="#PALEOmodel.ODE.calc_output_sol!"><code>calc_output_sol!</code></a> to recalculate model fields at timesteps used</li></ul><p><strong>Keywords</strong></p><p>As <a href="#PALEOmodel.ODE.integrate"><code>integrate</code></a>, with defaults:</p><ul><li><code>alg=Sundials.IDA()</code> (<code>integrateDAE</code>)</li><li><code>alg=Sundials.IDA(linear_solver=:KLU)</code> (<code>integrateDAEForwardDiff</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L228-L256">source</a></section></article><h3 id="Low-level-functions"><a class="docs-heading-anchor" href="#Low-level-functions">Low level functions</a><a id="Low-level-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.ODEfunction" href="#PALEOmodel.ODE.ODEfunction"><code>PALEOmodel.ODE.ODEfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ODEfunction(model::PB.Model, modeldata [; kwargs]) -&gt; SciMLBase.ODEFunction</code></pre><p>Contruct SciML ODEfunction <a href="https://diffeq.sciml.ai/latest/">https://diffeq.sciml.ai/latest/</a> with PALEO-specific setup</p><p>Keyword arguments are required to generate a Jacobian function (using automatic differentation).</p><p><strong>Keywords</strong></p><ul><li><code>jac_ad=:NoJacobian</code>: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>jac_ad_t_sparsity::Float64</code>: model time at which to calculate Jacobian sparsity pattern</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.DAEfunction" href="#PALEOmodel.ODE.DAEfunction"><code>PALEOmodel.ODE.DAEfunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DAEfunction(model::PB.Model, modeldata [; kwargs]) -&gt; SciMLBase.DAEFunction</code></pre><p>Contruct SciML DAEfunction <a href="https://diffeq.sciml.ai/latest/">https://diffeq.sciml.ai/latest/</a> with PALEO-specific setup</p><p>Keyword arguments are required to generate a Jacobian function (using automatic differentation).</p><p><strong>Keywords</strong></p><ul><li><code>jac_ad=:NoJacobian</code>: Jacobian to generate and use (:NoJacobian, :ForwardDiffSparse, :ForwardDiff)</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>jac_ad_t_sparsity::Float64</code>: model time at which to calculate Jacobian sparsity pattern</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L84-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.get_inconsistent_initial_deriv" href="#PALEOmodel.ODE.get_inconsistent_initial_deriv"><code>PALEOmodel.ODE.get_inconsistent_initial_deriv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_inconsistent_initial_deriv(
    initial_state, modeldata, initial_t, differential_vars, modeldae::SolverFunctions.ModelDAE
) -&gt; initial_deriv</code></pre><p>Create (inconsistent) <code>initial_deriv</code> for a DAE problem: ODE variables are consistent, DAE variables set to zero  ie rely on DAE solver to find them</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L348-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.print_sol_stats" href="#PALEOmodel.ODE.print_sol_stats"><code>PALEOmodel.ODE.print_sol_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_sol_stats(sol::SciMLBase.ODESolution)
print_sol_stats(sol::SciMLBase.DAESolution)
print_sol_stats(sol::SciMLBase.NonlinearSolution)</code></pre><p>Print solution statistics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L513-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODE.calc_output_sol!" href="#PALEOmodel.ODE.calc_output_sol!"><code>PALEOmodel.ODE.calc_output_sol!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">calc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.ODESolution, tspan, initial_state, modeldata)
calc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.DAESolution, tspan, initial_state, modeldata)
calc_output_sol!(outputwriter, model::PB.Model, sol::SciMLBase.NonlinearSolution, tspan, initial_state, modeldata)
calc_output_sol!(outputwriter, model::PB.Model, tsoln::AbstractVector, soln::AbstractVector,  modeldata)</code></pre><p>Iterate through solution and recalculate model fields (functions of state variables and time) and store in <code>outputwriter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>outputwriter::PALEOmodel.AbstractOutputWriter</code>: container for output</li><li><code>model::PB.Model</code> used to calculate solution</li><li><code>sol</code>: SciML solution object</li><li><code>tspan</code>:  (tstart, tstop) integration start and stop times</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>tsoln::AbstractVector</code>:  solution times</li><li><code>soln::AbstractVector</code>: solution state variables</li><li><code>modeldata::PB.Modeldata</code>: ModelData struct</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODE.jl#L416-L434">source</a></section></article><h2 id="Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)"><a class="docs-heading-anchor" href="#Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)">Steady-state solvers (Julia <a href="https://github.com/JuliaNLSolvers/NLsolve.jl"><code>NLsolve</code></a> based)</a><a id="Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solvers-(Julia-[NLsolve](https://github.com/JuliaNLSolvers/NLsolve.jl)-based)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate" href="#PALEOmodel.SteadyState.steadystate"><code>PALEOmodel.SteadyState.steadystate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate(run, initial_state, modeldata, tss [; kwargs...] )
steadystateForwardDiff(run, initial_state, modeldata, tss [; kwargs...] )</code></pre><p>Find steady-state solution (using <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> package)  and write to <code>outputwriter</code> (two records are written, for <code>initial_state</code> and the steady-state solution).</p><p><code>steadystateForwardDiff</code> has default keyword argument <code>jac_ad=:ForwardDiffSparse</code> to use automatic differentiation for sparse Jacobian.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tss</code>:  (yr) model tforce time for steady state solution</li></ul><p><strong>Optional Keywords</strong></p><ul><li><code>outputwriter::PALEOmodel.AbstractOutputWriter=run.output</code>: container to hold output</li><li><code>initial_time=-1.0</code>:  tmodel to write for first output record</li><li><code>solvekwargs=NamedTuple()</code>: NamedTuple of keyword arguments passed through to <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a>  (eg to set <code>method</code>, <code>ftol</code>, <code>iteration</code>, <code>show_trace</code>, <code>store_trace</code>).</li><li><code>jac_ad</code>: :NoJacobian, :ForwardDiffSparse, :ForwardDiff</li><li><code>use_norm=false</code>: not supported (must be false)</li><li><code>BLAS_num_threads=1</code>: number of LinearAlgebra.BLAS threads to use</li><li><code>generated_dispatch=true</code>: <code>true</code> to use autogenerated code (fast solve, slow compile)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SteadyState.jl#L23-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate_ptc" href="#PALEOmodel.SteadyState.steadystate_ptc"><code>PALEOmodel.SteadyState.steadystate_ptc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate_ptc(run, initial_state, modeldata, tspan, deltat_initial; kwargs...) 
steadystate_ptcForwardDiff(run, initial_state, modeldata, tspan, deltat_initial; kwargs...)</code></pre><p>Find steady-state solution and write to <code>outputwriter</code>, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps from <code>tspan[1]</code> to <code>tspan[2]</code> and <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLsolve.jl</a> as the non-linear solver.</p><p><code>steadystate_ptcForwardDiff</code> has keyword argument default <code>jac_ad=:ForwardDiffSparse</code> to use automatic differentiation for  sparse Jacobian.</p><p>Each pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton&#39;s method.</p><p>Initial pseudo-timestep Δt is <code>deltat_initial</code>, this is multiplied by <code>deltat_fac</code> for the next iteration until pseudo-time <code>tss_max</code> is reached. If an iteration fails, Δt is divided by <code>deltat_fac</code> and the iteration retried.</p><p>NB: this is a <em>very</em> naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate <code>deltat_fac</code> for each problem.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>: Vector or Tuple with <code>(initial_time, final_time)</code></li><li><code>deltat_initial</code>: initial pseudo-timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>deltat_fac=2.0</code>: factor to increase pseudo-timestep on success</li><li><code>tss_output=Float64[]</code>: Vector of model times at which to save output (empty Vector to save all output timesteps)</li><li><code>outputwriter=run.output</code>: output destination</li><li><code>solvekwargs=NamedTuple()</code>: arguments to pass through to NLsolve</li><li><code>max_iter=1000</code>: maximum number of PTC iterations</li><li><code>max_failed_iter=20</code>: maximum number of iterations that make no progress before exiting</li><li><code>jac_ad=:NoJacobian</code>: AD Jacobian to use</li><li><code>request_adchunksize=10</code>: ForwardDiff chunk size to request.</li><li><code>jac_cellranges=modeldata.cellranges_all</code>: CellRanges to use for Jacobian calculation (eg to restrict to an approximate Jacobian by using a cellrange with a non-default <code>operatorID</code>: in this case, Variables that are not calculated but needed for the Jacobian should set the <code>transfer_jacobian</code> attribute so that they will be copied)</li><li><code>enforce_noneg=false</code>: fail pseudo-timesteps that generate negative values for state variables.</li><li><code>use_norm=false</code>: not supported (must be false)</li><li><code>verbose=false</code>: true for detailed output</li><li><code>BLAS_num_threads=1</code>: restrict threads used by Julia BLAS (likely irrelevant if using sparse Jacobian?)</li><li><code>generated_dispatch=true</code>: true to use autogenerated code (fast solve, slow compile)</li><li>[Deprecated: <code>sol_min</code>: now has no effect, replace with <code>solve_kwargs=(project_region! = x-&gt;clamp!(x, sol_min, sol_max), )</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SteadyState.jl#L140-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyState.steadystate_ptc_splitdae" href="#PALEOmodel.SteadyState.steadystate_ptc_splitdae"><code>PALEOmodel.SteadyState.steadystate_ptc_splitdae</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate_ptc_splitdae(run, initial_state, modeldata, tspan, deltat_initial; kwargs...)</code></pre><p>As <a href="#PALEOmodel.SteadyState.steadystate_ptc"><code>steadystate_ptc</code></a>, with an inner Newton solve for per-cell algebraic constraints (eg quasi-steady-state reaction intermediates).</p><p><strong>Keywords (in common with <a href="#PALEOmodel.SteadyState.steadystate_ptc"><code>steadystate_ptc</code></a>)</strong></p><ul><li><code>deltat_fac</code></li><li><code>tss_output</code></li><li><code>outputwriter</code></li><li><code>solvekwargs</code></li><li><code>max_iter</code></li><li><code>max_failed_iter</code></li><li><code>request_adchunksize</code></li><li><code>jac_cellranges</code></li><li><code>enforce_noneg</code></li><li><code>verbose</code></li></ul><p><strong>Keywords (additional to <a href="#PALEOmodel.SteadyState.steadystate_ptc"><code>steadystate_ptc</code></a>)</strong></p><ul><li><code>operatorID_inner=3</code>: operatorID for Reactions to run for inner solve (typically all reservoirs and chemical reactions)</li><li><code>transfer_inner_vars=[&quot;tmid&quot;, &quot;volume&quot;, &quot;ntotal&quot;, &quot;Abox&quot;]</code>: Variables not calculated by <code>operatorID_inner</code> that need to be copied for  inner solve (additional to those with <code>transfer_jacobian</code> set).</li><li><code>inner_jac_ad::Symbol=:ForwardDiff</code>: form of automatic differentiation to use for Jacobian for inner <code>NonlinearNewton.solve</code> solver (options <code>:ForwardDiff</code>, <code>:ForwardDiffSparse</code>)</li><li><code>inner_start::Symbol=:current</code>: start value for inner solve (options <code>:initial</code>, <code>:current</code>, <code>:zero</code>)</li><li><code>inner_kwargs::NamedTuple=(verbose=0, miniters=2, reltol=1e-12, jac_constant=true, project_region=identity)</code>: keywords for inner  <code>NonlinearNewton.solve</code> solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SteadyState.jl#L278-L304">source</a></section></article><p>Function objects to project Newton steps into valid regions:</p><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ClampAll!" href="#PALEOmodel.SolverFunctions.ClampAll!"><code>PALEOmodel.SolverFunctions.ClampAll!</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ca! = ClampAll!(minvalue, maxvalue)
ca!(v)</code></pre><p>Function object to clamp all values in Vector <code>v</code> to specified range using <code>clamp!(v, minvalue, maxvalue)</code> (in-place, mutating version)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ClampAll" href="#PALEOmodel.SolverFunctions.ClampAll"><code>PALEOmodel.SolverFunctions.ClampAll</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ca = ClampAll(minvalue, maxvalue)
ca(v) -&gt; v</code></pre><p>Function object to clamp all values in Vector <code>v</code> to specified range using <code>clamp.(v, minvalue, maxvalue)</code> (out-of-place version)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L33-L39">source</a></section></article><h2 id="Steady-state-solvers-(Sundials-Kinsol-based):"><a class="docs-heading-anchor" href="#Steady-state-solvers-(Sundials-Kinsol-based):">Steady-state solvers (Sundials Kinsol based):</a><a id="Steady-state-solvers-(Sundials-Kinsol-based):-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solvers-(Sundials-Kinsol-based):" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SteadyStateKinsol.steadystate_ptc" href="#PALEOmodel.SteadyStateKinsol.steadystate_ptc"><code>PALEOmodel.SteadyStateKinsol.steadystate_ptc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystate_ptc(run, initial_state, modeldata, tspan, deltat_initial; 
    [,deltat_fac=2.0] [,tss_output] [,outputwriter] [,createkwargs] [,solvekwargs]
    [, use_jac_preconditioner] [,jac_cellranges] [, use_directional_ad] [, directional_ad_eltypestomap]
    [,verbose] [,  BLAS_num_threads]
)</code></pre><p>Find steady-state solution and write to <code>outputwriter</code>, using naive pseudo-transient-continuation with first order implicit Euler pseudo-timesteps and <a href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> as the non-linear solver.</p><p>Each pseudo-timestep solves the nonlinear system S(t+Δt) = S(t) + Δt dS/dt(t+Δt) for S(t+Δt), using a variant of Newton&#39;s method (preconditioned Newton-Krylov, with the Jacobian as preconditioner)</p><p>Initial pseudo-timestep Δt is <code>deltat_initial</code>, this is multiplied by <code>deltat_fac</code> for the next iteration until pseudo-time <code>tss_max</code> is reached. If an iteration fails, Δt is divided by <code>deltat_fac</code> and the iteration retried.</p><p>NB: this is a <em>very</em> naive initial implementation, there is currently no reliable error control to adapt pseudo-timesteps  to the rate of convergence, so requires some trial-and-error to set an appropiate <code>deltat_fac</code> for each problem.</p><p>Solver <a href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> options are set by arguments <code>createkwargs</code> (passed through to <a href="#PALEOmodel.Kinsol.kin_create"><code>PALEOmodel.Kinsol.kin_create</code></a>) and <code>solvekwargs</code> (passed through to <a href="#PALEOmodel.Kinsol.kin_solve"><code>PALEOmodel.Kinsol.kin_solve</code></a>).</p><p>If <code>use_jac_ad_preconditioner</code> is <code>true</code>, the AD Jacobian is used as preconditioner. The preconditioner (Jacobian) calculation can be modified by <code>jac_cellranges</code>, to specify a operatorIDs  so use only a subset of Reactions in order to  calculate an approximate Jacobian to use as the preconditioner.</p><p>If <code>use_directional_ad</code> is <code>true</code>, the Jacobian-vector product will be calculated using automatic differentiation (instead of  the default finite difference approximation).  <code>directional_ad_eltypestomap</code> can be used to specify Variable :datatype tags (strings) that should be mapped to the AD directional derivative datatype hence included in the AD directional derivative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SteadyStateKinsol.jl#L16-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol" href="#PALEOmodel.Kinsol"><code>PALEOmodel.Kinsol</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Kinsol</code></pre><p>Minimal Julia wrapper for the Sundials kinsol nonlinear system solver <a href="https://computing.llnl.gov/projects/sundials/kinsol">https://computing.llnl.gov/projects/sundials/kinsol</a></p><p>This closely follows the native C interface, as documented in the Kinsol manual, with conversion to-from native Julia types.</p><p>The main user-facing functions are <a href="#PALEOmodel.Kinsol.kin_create"><code>Kinsol.kin_create</code></a> and <a href="#PALEOmodel.Kinsol.kin_solve"><code>Kinsol.kin_solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Kinsol.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol.kin_create" href="#PALEOmodel.Kinsol.kin_create"><code>PALEOmodel.Kinsol.kin_create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kin_create(f, y0 [; kwargs...]) -&gt; kin</code></pre><p>Create and return a kinsol solver context <code>kin</code>, which can then be passed to <a href="#PALEOmodel.Kinsol.kin_solve"><code>kin_solve</code></a></p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Function of form f(fy::Vector{Float64}, y::Vector{Float64}, userdata)</li><li><code>y0::Vector</code> template Vector of initial values (used only to define problem dimension)</li></ul><p><strong>Keywords</strong></p><ul><li><code>userdata</code>: optional user data, passed through to <code>f</code> etc.</li><li><code>linear_solver</code>: linear solver to use (only partially implemented, supports :Dense, :Band, :FGMRES)</li><li><code>psolvefun</code>: optional preconditioner solver function (for :FGMRES)</li><li><code>psetupfun</code>: optional preconditioner setup function</li><li><code>jvfun</code>: optional Jacobian*vector  function (for :FGMRES)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Kinsol.jl#L96-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.Kinsol.kin_solve" href="#PALEOmodel.Kinsol.kin_solve"><code>PALEOmodel.Kinsol.kin_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kin_solve(
    kin, y0::Vector;
    [strategy] [, fnormtol] [, mxiter] [, print_level] [,y_scale] [, f_scale] [, noInitSetup]
) -&gt; (y, kin_stats)</code></pre><p>Solve nonlinear system using kinsol solver context <code>kin</code> (created by <a href="#PALEOmodel.Kinsol.kin_create"><code>kin_create</code></a>) and initial conditions <code>y0</code>. Returns solution <code>y</code> and solver statistics <code>kinstats</code>. <code>kinstats.returnflag</code> indicates success/failure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/Kinsol.jl#L188-L196">source</a></section></article><h2 id="Fixed-timestep-solvers"><a class="docs-heading-anchor" href="#Fixed-timestep-solvers">Fixed timestep solvers</a><a id="Fixed-timestep-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-timestep-solvers" title="Permalink"></a></h2><p>PALEO native fixed-timestep, first-order Euler integrators, with split-explicit and multi-threaded options. These are usually appropriate for larger biogeochemical models (eg ocean models using GCM transport matrices).</p><p>The low-level timestepping is provided by <a href="#PALEOmodel.ODEfixed.integrateFixed"><code>integrateFixed</code></a> and <a href="#PALEOmodel.ODEfixed.integrateFixedthreads"><code>integrateFixedthreads</code></a>,  with higher-level wrappers for common options provided by <a href="#PALEOmodel.ODEfixed.integrateEuler"><code>integrateEuler</code></a> etc.</p><h3 id="High-level-wrappers-2"><a class="docs-heading-anchor" href="#High-level-wrappers-2">High-level wrappers</a><a class="docs-heading-anchor-permalink" href="#High-level-wrappers-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateEuler" href="#PALEOmodel.ODEfixed.integrateEuler"><code>PALEOmodel.ODEfixed.integrateEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateEuler(run, initial_state, modeldata, tspan, Δt [; kwargs])</code></pre><p>Integrate <code>run.model</code> from <code>initial_state</code> using first-order Euler with fixed timestep.</p><p>Calls <a href="#PALEOmodel.ODEfixed.integrateFixed"><code>integrateFixed</code></a></p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt</code>: (yr) fixed timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>outputwriter::PALEOmodel.AbstractOutputWriter=run.output</code>: container to write model output to</li><li><code>report_interval=1000</code>: number of timesteps between progress update to console</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L14-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateSplitEuler" href="#PALEOmodel.ODEfixed.integrateSplitEuler"><code>PALEOmodel.ODEfixed.integrateSplitEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateSplitEuler(run, initial_state, modeldata, tspan, Δt_outer, n_inner;
                        cellranges_outer, cellranges_inner,
                        [,outputwriter])</code></pre><p>Integrate run.model representing:</p><p class="math-container">\[\frac{dS}{dt} =  f_{outer}(t, S) + f_{inner}(t, S)\]</p><p>using split first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and a shorter timestep <code>Δt_outer/n_inner</code> for <code>f_inner</code>.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_outer</code>. <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_inner</code>.</p><p>NB: the combined time derivative is written to <code>outputwriter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed outer timestep </li><li><code>n_inner</code>: number of inner timesteps per outer timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>cellranges_outer</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellranges_inner</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_inner</code>.</li><li><code>outputwriter::PALEOmodel.AbstractOutputWriter=run.output</code>: container to write model output to</li><li><code>report_interval=1000</code>: number of outer timesteps between progress update to console</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L58-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateEulerthreads" href="#PALEOmodel.ODEfixed.integrateEulerthreads"><code>PALEOmodel.ODEfixed.integrateEulerthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateEulerthreads(run, initial_state, modeldata, cellranges, tspan, Δt;
    outputwriter=run.output, report_interval=1000)</code></pre><p>Integrate run.model using first-order Euler with fixed timestep <code>Δt</code>, with tiling over multiple threads.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>cellranges::Vector{Vector{AbstractCellRange}}</code>: Vector of Vector-of-cellranges, one per thread (so length(cellranges) == Threads.nthreads).</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt</code>: (yr) fixed outer timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>outputwriter::PALEOmodel.AbstractOutputWriter=run.output</code>: container to write model output to</li><li><code>report_interval=1000</code>: number of outer timesteps between progress update to console</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L142-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateSplitEulerthreads" href="#PALEOmodel.ODEfixed.integrateSplitEulerthreads"><code>PALEOmodel.ODEfixed.integrateSplitEulerthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateSplitEulerthreads(run, initial_state, modeldata, tspan, Δt_outer, n_inner::Int; 
                            cellranges_outer, cellranges_inner, [,outputwriter] [, report_interval])</code></pre><p>Integrate run.model using split first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and a shorter timestep <code>Δt_outer/n_inner</code> for <code>f_inner</code>.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_outer</code>.  <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_inner</code>.</p><p>Uses <code>Threads.nthreads</code> threads and tiling described by <code>cellranges_inner</code> and <code>cellranges_outer</code> (each a <code>Vector</code> of <code>Vector{AbstractCellRange}</code>, one per thread).</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed outer timestep </li><li><code>n_inner</code>: number of inner timesteps per outer timestep (0 for non-split solver)</li></ul><p><strong>Keywords</strong></p><ul><li><code>cellranges_outer::Vector{Vector{AbstractCellRange}}</code>: Vector of list-of-cellranges, one list per thread (so length(cellranges) == Threads.nthreads), with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellranges_inner::Vector{Vector{AbstractCellRange}}</code>: As <code>cellranges_outer</code>, with <code>operatorID</code> defining <code>f_inner</code>.</li><li><code>outputwriter::PALEOmodel.AbstractOutputWriter=run.output</code>: container to write model output to</li><li><code>report_interval=1000</code>: number of outer timesteps between progress update to console</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L208-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler" href="#PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler"><code>PALEOmodel.ODELocalIMEX.integrateLocalIMEXEuler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateLocalIMEXEuler(run, initial_state, modeldata, tspan, Δt_outer [; kwargs...])</code></pre><p>Integrate run.model representing:</p><p class="math-container">\[\frac{dS}{dt} =  f_{outer}(t, S) + f_{inner}(t, S)\]</p><p>using first-order Euler with <code>Δt_outer</code> for <code>f_outer</code> and implicit first-order Euler for <code>f_inner</code>, where <code>f_inner</code> is local (within-cell, ie no transport), for a single Domain, and uses only <code>StateExplicit</code> and <code>Deriv</code> variables.</p><p><code>f_outer</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellranges_outer</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellranges_outer</code>.  <code>f_inner</code> is defined by calling <code>PALEOboxes.do_deriv</code> with <code>cellrange_inner</code> hence corresponds to those <code>Reactions</code> with <code>operatorID</code> of <code>cellrange_inner</code>.</p><p>NB: the combined time derivative is written to <code>outputwriter</code>.</p><p><strong>Arguments</strong></p><ul><li><code>run::Run</code>: struct with <code>model::PB.Model</code> to integrate and <code>output</code> field</li><li><code>initial_state::AbstractVector</code>: initial state vector</li><li><code>modeldata::Modeldata</code>: ModelData struct with appropriate element type for forward model</li><li><code>tspan</code>:  (tstart, toutput1, toutput2, ..., tstop) integration start, output, stop times</li><li><code>Δt_outer</code>: (yr) fixed timestep</li></ul><p><strong>Keywords</strong></p><ul><li><code>cellranges_outer</code>: Vector of <code>CellRange</code> with <code>operatorID</code> defining <code>f_outer</code>.</li><li><code>cellrange_inner</code>: A single <code>CellRange</code> with <code>operatorID</code> defining <code>f_inner</code>.</li><li><code>exclude_var_nameroots</code>: State variables that are modified by Reactions in <code>cellrange_inner</code>, but not needed to find implicit solution (ie reaction rates etc don&#39;t depend on them).</li><li>[<code>outputwriter=run.output</code>: <code>PALEOmodel.AbstractOutputWriter</code> instance to write model output to]</li><li>[<code>report_interval=1000</code>: number of outer timesteps between progress update to console]</li><li>[<code>Lnorm_inf_max=1e-3</code>:  normalized error tolerance for implicit solution]</li><li>[<code>niter_max=10</code>]: maximum number of Newton iterations</li><li>[<code>request_adchunksize=4</code>]: request ForwardDiff AD chunk size (will be restricted to an upper limit)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODELocalIMEX.jl#L15-L48">source</a></section></article><h3 id="Low-level-timesteppers"><a class="docs-heading-anchor" href="#Low-level-timesteppers">Low-level timesteppers</a><a id="Low-level-timesteppers-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-timesteppers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateFixed" href="#PALEOmodel.ODEfixed.integrateFixed"><code>PALEOmodel.ODEfixed.integrateFixed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateFixed(run, initial_state, modeldata, tspan, Δt_outer;
            timesteppers, outputwriter=run.output, report_interval=1000)</code></pre><p>Fixed timestep integration, with time step implemented by <code>timesteppers</code>,</p><pre><code class="nohighlight hljs">`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ...], ...]`</code></pre><p>Where <code>timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L362-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ODEfixed.integrateFixedthreads" href="#PALEOmodel.ODEfixed.integrateFixedthreads"><code>PALEOmodel.ODEfixed.integrateFixedthreads</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrateFixedthreads(run, initial_state, modeldata, tspan, Δt_outer;
            timesteppers, outputwriter=run.output, report_interval=1000)</code></pre><p>Fixed timestep integration using <code>Threads.nthreads()</code> threads, with time step implemented by <code>timesteppers</code>,</p><pre><code class="nohighlight hljs">`timesteppers = [ [(timestep_function, cellranges, timestep_ctxt), ... (1 per thread)], ...]`</code></pre><p>Where <code>timestep_function(model, modeldata, cellranges, timestep_ctxt, touter, Δt, barrier)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ODEfixed.jl#L442-L451">source</a></section></article><h3 id="Thread-barriers"><a class="docs-heading-anchor" href="#Thread-barriers">Thread barriers</a><a id="Thread-barriers-1"></a><a class="docs-heading-anchor-permalink" href="#Thread-barriers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ThreadBarriers.ThreadBarrierAtomic" href="#PALEOmodel.ThreadBarriers.ThreadBarrierAtomic"><code>PALEOmodel.ThreadBarriers.ThreadBarrierAtomic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadBarrierAtomic</code></pre><p>Thread synchronisation barrier for <code>Threads.nthreads()</code> Julia Threads.  Uses a pair of Atomic variables to avoid the need for locks. Resets so can be reused.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">barrier = ThreadBarrierAtomic(&quot;my barrier&quot;)    
Threads.@threads for t in 1:Threads.nthreads()  
    # do stuff
    
    wait_barrier(barrier)  # blocks until all threads reach this point

    # do more stuff
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ThreadBarriers.jl#L19-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.ThreadBarriers.ThreadBarrierCond" href="#PALEOmodel.ThreadBarriers.ThreadBarrierCond"><code>PALEOmodel.ThreadBarriers.ThreadBarrierCond</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ThreadBarrierCond</code></pre><p>Thread synchronisation barrier for <code>Threads.nthreads()</code> Julia Threads using Condition variable and associated lock. Resets so can be reused. </p><p>NB: testing on Julia 1.6 suggests this is slow. </p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">barrier = ThreadBarrierCond(&quot;my barrier&quot;)    
Threads.@threads for t in 1:Threads.nthreads()  
    # do stuff
    
    wait_barrier(barrier)  # blocks until all threads reach this point

    # do more stuff
end</code></pre><p><strong>Implementation:</strong></p><p>Uses a condition variable (with associated lock) and a counter. See eg <a href="http://web.eecs.utk.edu/~huangj/cs360/360/notes/CondVar/lecture.html">http://web.eecs.utk.edu/~huangj/cs360/360/notes/CondVar/lecture.html</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/ThreadBarriers.jl#L80-L103">source</a></section></article><h2 id="Variable-aggregation"><a class="docs-heading-anchor" href="#Variable-aggregation">Variable aggregation</a><a id="Variable-aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-aggregation" title="Permalink"></a></h2><p>A <a href="#PALEOmodel.SolverView"><code>SolverView</code></a> uses a collection of <code>PALEOboxes.VariableAggregator</code>s to assemble model state Variables and associated time derivatives into contiguous Vectors, for the convenience of standard numerical ODE / DAE solvers.  See <a href="../MathematicalFormulation/#Mathematical-formulation-of-the-reaction-transport-problem">Mathematical formulation of the reaction-transport problem</a>. </p><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverView" href="#PALEOmodel.SolverView"><code>PALEOmodel.SolverView</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverView(model, modeldata, arrays_idx; [verbose=true]) 
SolverView(model, modeldata, cellranges; [verbose=false], [indices_from_cellranges=true])</code></pre><p>Provides a view on the whole or some part of the Model for a numerical solver.</p><p>Contains <code>PALEOboxes.VariableAggregator</code>s for a subset of spatial locations   (Domains, indices within spatial Domains) and Variables, with:     - ODE paired <code>stateexplicit</code> (S) and <code>stateexplicit_deriv</code> (dS/dt), where dS/dt = F(S).     - Implicit-ODE paired <code>total</code> (T) and <code>total_deriv</code> (dT/dt), where dT(S)/dt = F(T(S)) with         <code>total</code> a function of explicit and implicit state Variables <code>statexplicit</code> and <code>state</code> (S).     - Algebraic <code>constraint</code>s (C), where C(S) = 0 with C a function of explicit and implicit state Variables <code>statexplicit</code> and <code>state</code> (S),</p><p>The number of <code>total</code> + number of <code>constraint</code> Variables must equal the number of implicit <code>state</code> Variables.</p><p>Optional access methods provide an <code>ODE/DAE solver</code> view with composite <code>statevar</code> and <code>statevar_sms</code>,where:</p><pre><code class="nohighlight hljs">- `statevar` is a concatenation of `stateexplicit` and `state` ([`set_statevar!`](@ref))
- `statevar_sms` is a concatenation of `stateexplicit_deriv`, `total_deriv`, `constraints` ([`get_statevar_sms!`](@ref))</code></pre><p>Constructors create a <a href="#PALEOmodel.SolverView"><code>SolverView</code></a> for the entire model from <code>modeldata</code> array set <code>arrays_idx</code>,  or for a subset of Model Variables defined by the Domains and operatorIDs of <code>cellranges</code>. </p><p><strong>Keywords</strong></p><ul><li><code>indices_from_cellranges=true</code>: true to restrict to the index ranges from <code>cellranges</code>, false to just use <code>cellranges</code> to define Domains</li></ul><p>and take the whole of each Domain.</p><ul><li><code>hostdep_all=true</code>: true to include host dependent not-state Variables from all Domains</li><li><code>reallocate_hostdep_eltype=Float64</code>: a data type to reallocate <code>hostdep</code> Variables eg to replace any</li></ul><p>AD types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverView.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.set_default_solver_view!" href="#PALEOmodel.set_default_solver_view!"><code>PALEOmodel.set_default_solver_view!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_default_solver_view!(model, modeldata)</code></pre><p>(Optional, used to set <code>modeldata.solver_view_all</code> to a <a href="#PALEOmodel.SolverView"><code>SolverView</code></a>) for the whole model, and set <code>modeldata.hostdep_data</code> to any non-state-variable host dependent Variables)</p><p><code>reallocate_hostdep_eltype</code> a data type to reallocate <code>hostdep_data</code> eg to replace any AD types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverView.jl#L354-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.copy_norm!" href="#PALEOmodel.copy_norm!"><code>PALEOmodel.copy_norm!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>copy norm values from state variable etc data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverView.jl#L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.set_statevar!" href="#PALEOmodel.set_statevar!"><code>PALEOmodel.set_statevar!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_statevar!(sv::SolverView, u)</code></pre><p>Set combined stateexplicit, state variables from u</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverView.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.get_statevar_sms!" href="#PALEOmodel.get_statevar_sms!"><code>PALEOmodel.get_statevar_sms!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_statevar_sms!(du, sv::SolverView)</code></pre><p>Get combined derivatives and constraints, eg for an ODE solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverView.jl#L146-L150">source</a></section></article><h2 id="Function-objects"><a class="docs-heading-anchor" href="#Function-objects">Function objects</a><a id="Function-objects-1"></a><a class="docs-heading-anchor-permalink" href="#Function-objects" title="Permalink"></a></h2><p>Function objects are callable structs with function signatures required by DifferentialEquations or other solvers to calculate model time derivative, Jacobian, etc. They combine variable aggregation (using <code>PALEOboxes.VariableAggregator</code>s or <a href="#PALEOmodel.SolverView"><code>PALEOmodel.SolverView</code></a>) with corresponding Reaction dispatch lists.</p><h3 id="ODE-function-objects"><a class="docs-heading-anchor" href="#ODE-function-objects">ODE function objects</a><a id="ODE-function-objects-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-function-objects" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ModelODE" href="#PALEOmodel.SolverFunctions.ModelODE"><code>PALEOmodel.SolverFunctions.ModelODE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelODE(
    modeldata; 
    solver_view=modeldata.solver_view_all,
    dispatchlists=modeldata.dispatchlists_all
) -&gt; f::ModelODE</code></pre><p>Function object to calculate model time derivative and adapt to SciML ODE solver interface</p><p>Call as <code>f(du,u, p, t)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L47-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ModelODE_at_t" href="#PALEOmodel.SolverFunctions.ModelODE_at_t"><code>PALEOmodel.SolverFunctions.ModelODE_at_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelODE_at_t</code></pre><p>Function object to calculate model derivative at <code>t</code>, eg to adapt to ForwardDiff or NLsolve interface</p><p>Calculates F = du/dt(t)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L87-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.JacODEForwardDiffDense" href="#PALEOmodel.SolverFunctions.JacODEForwardDiffDense"><code>PALEOmodel.SolverFunctions.JacODEForwardDiffDense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacODEForwardDiffDense(
    modeldata; 
    solver_view=modeldata.solver_view_all,
    dispatchlists=modeldata.dispatchlists_all,
    du_template, 
    jacconf,
) -&gt; jac::JacODEForwardDiffDense</code></pre><p>Function object to calculate dense Jacobian in form required for SciML ODE solver.</p><p><code>solver_view</code>, <code>dispatchlists</code> should correspond to <code>modeldata</code>, which should have the appropriate element type for ForwardDiff Dual numbers.</p><p>Call as <code>jac(J, u, p, t)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L112-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.JacODEForwardDiffSparse" href="#PALEOmodel.SolverFunctions.JacODEForwardDiffSparse"><code>PALEOmodel.SolverFunctions.JacODEForwardDiffSparse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacODEForwardDiffSparse(
    modeldata; 
    solver_view=modeldata.solver_view_all,
    dispatchlists=modeldata.dispatchlists_all,
    du_template,
    throw_on_nan, 
    jac_cache,
) -&gt; jac::JacODEForwardDiffSparse</code></pre><p>Function object to calculate sparse Jacobian in form required for SciML ODE solver.</p><p><code>solver_view</code>, <code>dispatchlists</code> should correspond to <code>modeldata</code>, which should have the appropriate element type for ForwardDiff Dual numbers.</p><p>Call as <code>jac(J, u, p, t)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L159-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.JacODE_at_t" href="#PALEOmodel.SolverFunctions.JacODE_at_t"><code>PALEOmodel.SolverFunctions.JacODE_at_t</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacODE_at_t</code></pre><p>Function object to calculate ODE model Jacobian at <code>t</code>, eg to adapt to NLsolve interface</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L227-L231">source</a></section></article><h3 id="DAE-function-objects"><a class="docs-heading-anchor" href="#DAE-function-objects">DAE function objects</a><a id="DAE-function-objects-1"></a><a class="docs-heading-anchor-permalink" href="#DAE-function-objects" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ModelDAE" href="#PALEOmodel.SolverFunctions.ModelDAE"><code>PALEOmodel.SolverFunctions.ModelDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelDAE</code></pre><p>Function object to calculate model residual <code>G</code> and adapt to SciML DAE solver interface.</p><p>If using Total variables, <code>odeimplicit</code> should be an <a href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffDense"><code>ImplicitForwardDiffDense</code></a> or <a href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse"><code>ImplicitForwardDiffSparse</code></a>, otherwise <code>nothing</code>.</p><p>Provides function signature:</p><pre><code class="nohighlight hljs">(fdae::ModelDAE)(G, dsdt, s, p, t)</code></pre><p>where residual <code>G(dsdt,s,p,t)</code> is:</p><ul><li><code>-dsdt + F(s)</code>  (for ODE-like state Variables s with time derivative F given explicitly in terms of s)</li><li><code>F(s)</code> (for algebraic constraints)</li><li><code>duds*dsdt + F(s, u(s))</code> (for Total variables u that depend implicitly on state Variables s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L248-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.JacDAE" href="#PALEOmodel.SolverFunctions.JacDAE"><code>PALEOmodel.SolverFunctions.JacDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JacDAE</code></pre><p>Function object to calculate Jacobian in form required for SciML DAE solver</p><p><code>odejac</code> should be a <a href="#PALEOmodel.SolverFunctions.JacODEForwardDiffDense"><code>JacODEForwardDiffDense</code></a> or <a href="#PALEOmodel.SolverFunctions.JacODEForwardDiffSparse"><code>JacODEForwardDiffSparse</code></a></p><p>If using Total variables, <code>odeimplicit</code> should be an <a href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffDense"><code>ImplicitForwardDiffDense</code></a> or <a href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse"><code>ImplicitForwardDiffSparse</code></a>, otherwise <code>nothing</code>.</p><p>Provides function signature:</p><pre><code class="nohighlight hljs">(jdae::JacDAE)(J, dsdt, s, p, γ, t)</code></pre><p>Calculates Jacobian <code>J</code> in the form <code>γ*dG/d(dsdt) + dG/ds</code> where <code>γ</code> is given by the solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L315-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.TotalForwardDiff" href="#PALEOmodel.SolverFunctions.TotalForwardDiff"><code>PALEOmodel.SolverFunctions.TotalForwardDiff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TotalForwardDiff</code></pre><p>Calculate Total variables, with function signature required by ForwardDiff</p><p>Calling:</p><pre><code class="nohighlight hljs">set_t!(tfd::TotalForwardDiff, t)
tfd(T, u)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L361-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ImplicitForwardDiffDense" href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffDense"><code>PALEOmodel.SolverFunctions.ImplicitForwardDiffDense</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitForwardDiffDense</code></pre><p>Calculate dT/dS required for a model containing implicit Total variables, using ForwardDiff and dense AD</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L393-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse" href="#PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse"><code>PALEOmodel.SolverFunctions.ImplicitForwardDiffSparse</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImplicitForwardDiffSparse</code></pre><p>Calculate dT/dS required for a model containing implicit Total variables, using ForwardDiff and  sparse AD with <code>SparseDiffTools.forwarddiff_color_jacobian!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PALEOtoolkit/PALEOmodel.jl/blob/0facd81c4c5c72a5843b828de7acc692f0da7297/src/SolverFunctions.jl#L423-L428">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../HOWTOsmallnegativevalues/">« Managing small and negative values</a><a class="docs-footer-nextpage" href="../PALEOmodelOutput/">PALEOmodel output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 20 August 2023 12:54">Sunday 20 August 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
